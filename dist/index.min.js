var Single=function(){"use strict";const s=Symbol("DISPOSED"),e=s=>"object"==typeof s&&"function"==typeof s.dispose&&"function"==typeof s.isDisposed,r=s=>"object"==typeof s&&"function"==typeof s[Symbol.iterator],n=s=>"object"==typeof s&&"function"==typeof s.onSubscribe,o={dispose:()=>{},isDisposed:()=>!1},t=s=>s instanceof Promise||!!s&&("object"==typeof s||"function"==typeof s)&&"function"==typeof s.then;function i(s){if(!this.disposable.isDisposed())try{void 0===s?this.onError("onSuccess called with undefined."):this.onSuccess(s)}finally{this.disposable.dispose()}}function c(s){let e=s;if(s instanceof Error||(e=new Error("onError called with a non-Error value.")),!this.disposable.isDisposed())try{this.onError(e)}finally{this.disposable.dispose()}}class u{constructor(s){this.state=!1,this.onDispose=s}setDisposable(r){e(r)&&(this.state===s?r.dispose():this.state=r)}fire(){const{onDispose:e}=this;this.state=s,"function"==typeof e&&e(),this.onDispose=void 0}dispose(){const{state:r}=this;r!==s&&(e(r)?(r.isDisposed()||this.state.dispose(),r.isDisposed()&&this.fire()):this.fire())}isDisposed(){const{state:r}=this;return e(r)?!!r.isDisposed()&&(this.fire(),!0):r===s}}class b{constructor(){this.set=[],this.disposed=!1}add(s){e(s)&&(this.disposed?s.dispose():this.set.push(s))}dispose(){if(!this.disposed){for(const s of this.set)s.dispose();this.set=void 0,this.disposed=s}}isDisposed(){return this.disposed===s}}const a=s=>s,l=s=>{throw s},d=s=>({onSubscribe:s.onSubscribe,onSuccess:"function"==typeof s.onSuccess?s.onSuccess:a,onError:"function"==typeof s.onError?s.onError:l}),f=(s,e)=>{const r=new u;s.onSubscribe(r),r.isDisposed()||(s.onSuccess(e),r.dispose())},h=(s,e)=>{const{onSubscribe:r,onError:n}=d(s),o=new u;r(o),o.isDisposed()||(n(e),o.dispose())};const p=s=>{if(!r(s))return U(new Error("Single.amb: sources is not Iterable."));const e=new os;return e.sources=s,e.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=d(s),o=new b;n(o);const{sources:t}=this,i=t.length;for(let s=0;s<i;s+=1){if(o.isDisposed())return;const n=t[s];if(!(n instanceof os)){r(new Error("Single.amb: One of the sources is a non-Single.")),o.dispose();break}n.subscribeWith({onSubscribe(s){o.add(s)},onSuccess(s){e(s),o.dispose()},onError(s){r(s),o.dispose()}})}n(o)}.bind(e),e};const S=(s,e)=>{if(!(e instanceof os))return s;const r=new os;return r.source=s,r.other=e,r.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=d(s),o=new b;n(o);const{source:t,other:i}=this;t.subscribeWith({onSubscribe(s){o.add(s)},onSuccess(s){e(s),o.dispose()},onError(s){r(s),o.dispose()}}),i.subscribeWith({onSubscribe(s){o.add(s)},onSuccess(s){e(s),o.dispose()},onError(s){r(s),o.dispose()}})}.bind(r),r};const E=s=>{const e=new os;return e.source=s,e.cached=!1,e.subscribed=!1,e.observers=[],e.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=d(s),{source:o,cached:t,observers:i,subscribed:c}=this;if(t){const s=new u;n(s);const{value:o,error:t}=this;void 0!==o&&e(o),void 0!==t&&r(o),s.dispose()}else{const e=i.length;i[e]=s,n(new u(()=>{i.splice(e,1)})),c||(o.subscribeWith({onSubscribe(){},onSuccess:s=>{this.cached=!0,this.value=s;for(const e of i)e.onSuccess(s);this.observers=void 0},onError:s=>{this.cached=!0,this.error=s;for(const e of i)e.onError(s);this.observers=void 0}}),this.subscribed=!0)}}.bind(e),e};const w=s=>{if("function"!=typeof s)return U(new Error("Single.create: There are no subscribers."));const e=new os;return e.subscriber=s,e.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=d(s),o=new u;o.onSuccess=i.bind(this),o.onError=c.bind(this),this.disposable=o,this.onSuccess=e,this.onError=r,n(o);try{this.subscriber(o)}catch(s){o.onError(s)}}.bind(e),e},m=(s,e)=>{if("function"!=typeof e)return s;let r;try{if(!((r=e(s))instanceof os))throw new Error("Single.compose: transformer returned a non-Single.")}catch(s){r=U(s)}return r},y=(s,e)=>s===e;const v=(s,e,r)=>{if(void 0===e)return s;let n=r;"function"!=typeof n&&(n=y);const o=new os;return o.source=s,o.value=e,o.comparer=n,o.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=d(s),{value:o,comparer:t}=this;this.source.subscribeWith({onSubscribe:n,onSuccess(s){let n;try{n=t(s,o)}catch(s){return void r(s)}e(n)},onError:r})}.bind(o),o};const D=s=>{const e=new os;return e.supplier=s,e.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=d(s);let o,t;try{if(!((o=this.supplier())instanceof os))throw new Error("Single.defer: supplier returned a non-Single.")}catch(s){t=s}void 0!==t?h(s,t):o.subscribeWith({onSubscribe:n,onSuccess:e,onError:r})}.bind(e),e};const g=(s,e,r)=>{if("number"!=typeof e)return s;const n=new os;return n.source=s,n.amount=e,n.doDelayError=r,n.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=s;let o;const t=new u(()=>{void 0!==o&&clearTimeout(o)}),{amount:i,doDelayError:c}=this;n(t),this.source.subscribeWith({onSubscribe(s){t.setDisposable(s)},onSuccess(s){o=setTimeout(()=>{e(s),t.dispose()},i)},onError(s){o=setTimeout(()=>{r(s),t.dispose()},c?i:0)}})}.bind(n),n};const A=(s,e)=>{if("number"!=typeof e)return s;const r=new os;return r.source=s,r.amount=e,r.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=s,{amount:o}=this;let t;const i=new u(()=>{void 0!==t&&clearTimeout(t)});n(i),t=setTimeout(()=>{this.source.subscribeWith({onSubscribe(s){i.setDisposable(s)},onSuccess(s){e(s),i.dispose()},onError(s){r(s),i.dispose()}})},o)}.bind(r),r};const W=(s,e)=>{if(!(e instanceof os))return s;const r=new os;return r.source=s,r.other=e,r.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=s,{source:o,other:t}=this,i=new u;n(i),t.subscribeWith({onSubscribe(s){i.setDisposable(s)},onSuccess(){i.isDisposed()||o.subscribeWith({onSubscribe(s){i.setDisposable(s)},onSuccess(s){e(s),i.dispose()},onError(s){r(s),i.dispose()}})},onError(s){r(s),i.dispose()}})}.bind(r),r};const z=(s,e)=>{if("function"!=typeof e)return s;const r=new os;return r.source=s,r.callable=e,r.subscribeActual=function(s){const{onSubscribe:e,onSuccess:r,onError:n}=s,{source:o,callable:t}=this;o.subscribeWith({onSubscribe:e,onSuccess(s){r(s),t(s)},onError:n})}.bind(r),r};const T=(s,e)=>{if("function"!=typeof e)return s;const r=new os;return r.source=s,r.callable=e,r.subscribeActual=function(s){const{onSubscribe:e,onSuccess:r,onError:n}=s,{source:o,callable:t}=this;o.subscribeWith({onSubscribe:e,onSuccess(s){r(s),t()},onError(s){n(s),t()}})}.bind(r),r};const O=(s,e)=>{if("function"!=typeof e)return s;const r=new os;return r.source=s,r.callable=e,r.subscribeActual=function(s){const{onSubscribe:e,onSuccess:r,onError:n}=s,{source:o,callable:t}=this;let i=!1;const c=new u(()=>{i||(t(),i=!0)});o.subscribeWith({onSubscribe(s){c.setDisposable(s),e(c)},onSuccess(s){r(s),i||(t(),i=!0)},onError(s){n(s),i||(t(),i=!0)}})}.bind(r),r};const P=(s,e)=>{if("function"!=typeof e)return s;const r=new os;return r.source=s,r.callable=e,r.subscribeActual=function(s){const{onSubscribe:e,onSuccess:r,onError:n}=s,{source:o,callable:t}=this,i=new u(t);e(i),o.subscribeWith({onSubscribe(s){i.setDisposable(s)},onSuccess(s){r(s),i.dispose()},onError(s){n(s),i.dispose()}})}.bind(r),r};const R=(s,e)=>{if("function"!=typeof e)return s;const r=new os;return r.source=s,r.callable=e,r.subscribeActual=function(s){const{onSubscribe:e,onSuccess:r,onError:n}=s,{source:o,callable:t}=this;o.subscribeWith({onSubscribe:e,onSuccess:r,onError(s){t(s),n(s)}})}.bind(r),r};const j=(s,e)=>{if("function"!=typeof e)return s;const r=new os;return r.source=s,r.callable=e,r.subscribeActual=function(s){const{onSubscribe:e,onSuccess:r,onError:n}=s,{source:o,callable:t}=this;o.subscribeWith({onSubscribe:e,onSuccess(s){t(s),r(s)},onError(s){t(void 0,s),n(s)}})}.bind(r),r};const k=(s,e)=>{if("function"!=typeof e)return s;const r=new os;return r.source=s,r.callable=e,r.subscribeActual=function(s){const{onSubscribe:e,onSuccess:r,onError:n}=s,{source:o,callable:t}=this;o.subscribeWith({onSubscribe:e,onSuccess(s){t(s),r(s)},onError:n})}.bind(r),r};const I=(s,e)=>{if("function"!=typeof e)return s;const r=new os;return r.source=s,r.callable=e,r.subscribeActual=function(s){const{onSubscribe:e,onSuccess:r,onError:n}=s,{source:o,callable:t}=this;o.subscribeWith({onSubscribe(s){t(s),e(s)},onSuccess:r,onError:n})}.bind(r),r};const x=(s,e)=>{if("function"!=typeof e)return s;const r=new os;return r.source=s,r.callable=e,r.subscribeActual=function(s){const{onSubscribe:e,onSuccess:r,onError:n}=s,{source:o,callable:t}=this;o.subscribeWith({onSubscribe:e,onSuccess(s){t(),r(s)},onError(s){t(),n(s)}})}.bind(r),r};const U=s=>{let e=s;s instanceof Error||(e=new Error("Single.error received a non-Error value.")),"function"!=typeof s&&(e=(s=>()=>s)(e));const r=new os;return r.supplier=e,r.subscribeActual=function(s){let e;try{if(void 0===(e=this.supplier()))throw new Error("Single.error: Error supplier returned an undefined value.")}catch(s){e=s}h(s,e)}.bind(r),r};const C=(s,e)=>{if("function"!=typeof e)return s;const r=new os;return r.source=s,r.mapper=e,r.subscribeActual=function(s){const{onSubscribe:e,onError:r,onSuccess:n}=s,o=new u;e(o);const{mapper:t,source:i}=this;i.subscribeWith({onSubscribe(s){o.setDisposable(s)},onSuccess(s){let e;try{if(!((e=t(s))instanceof os))throw new Error("Single.flatMap: mapper returned a non-Single")}catch(s){return void r(s)}e.subscribeWith({onSubscribe(s){o.setDisposable(s)},onSuccess:n,onError:r})},onError:r})}.bind(r),r};const M=s=>{if("function"!=typeof s)return U(new Error("Single.fromCallable: callable received is not a function."));const e=new os;return e.callable=s,e.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=s,o=new u;n(o),this.disposable=o,this.onSuccess=e,this.onError=r;const b=i.bind(this),a=c.bind(this);let l;try{l=this.callable()}catch(s){return void a(s)}t(l)?N(l).subscribe(e,r):b(l)}.bind(e),e};const N=s=>{if(!t(s))return U(new Error("Single.fromPromise: expects a Promise-like value."));const e=new os;return e.promise=s,e.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=s,o=new u;n(o),this.disposable=o,this.onSuccess=e,this.onError=r,this.promise.then(i.bind(this),c.bind(this))}.bind(e),e};const F=s=>{if("function"!=typeof s)return U(new Error("Single.fromResolvable: expects a function."));const e=new os;return e.subscriber=s,e.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=s,o=new u;n(o),this.disposable=o,this.onSuccess=e,this.onError=r;const t=i.bind(this),b=c.bind(this);this.subscriber(t,b)}.bind(e),e};const q=s=>{if(void 0===s)return U(new Error("Single.just: received an undefined value."));const e=new os;return e.value=s,e.subscribeActual=function(s){f(s,this.value)}.bind(e),e};const B=(s,e)=>{if("function"!=typeof e)return s;const r=new os;return r.source=s,r.operator=e,r.subscribeActual=function(s){let e;try{if(e=this.operator(s),!n(e))throw new Error("Single.lift: operator returned a non-Observer.")}catch(e){return void h(s,e)}this.source.subscribeWith(e)}.bind(r),r},G=s=>s;const H=(s,e)=>{let r=e;"function"!=typeof e&&(r=G);const n=new os;return n.source=s,n.mapper=r,n.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=d(s),{mapper:o}=this;this.source.subscribeWith({onSubscribe:n,onSuccess(s){let n;try{if(void 0===(n=o(s)))throw new Error("Single.map: mapper function returned an undefined value.")}catch(s){return void r(s)}e(n)},onError:r})}.bind(n),n};const J=s=>{if(!(s instanceof os))return U(new Error("Single.merge: source is not a Single."));const e=new os;return e.source=s,e.subscribeActual=function(s){const{onSubscribe:e,onError:r,onSuccess:n}=d(s),o=new u;e(o),this.source.subscribeWith({onSubscribe(s){o.setDisposable(s)},onSuccess(s){let e=s;s instanceof os||(e=U(new Error("Single.merge: source emitted a non-Single value."))),e.subscribeWith({onSubscribe(s){o.setDisposable(s)},onSuccess:n,onError:r})},onError:r})}.bind(e),e};const K=(s,e)=>{if(!("function"==typeof e||e instanceof os))return s;const r=new os;return r.source=s,r.resumeIfError=e,r.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=d(s),{source:o,resumeIfError:t}=this,i=new u;n(i),o.subscribeWith({onSubscribe(s){i.setDisposable(s)},onSuccess:e,onError(s){let n;if("function"==typeof t)try{if(void 0===(n=t(s)))throw new Error("Single.onErrorResumeNext: returned an non-Single.")}catch(e){return void r(new Error([s,e]))}else n=t;n.subscribeWith({onSubscribe(s){i.setDisposable(s)},onSuccess:e,onError:r})}})}.bind(r),r};const L=(s,e)=>{if("function"!=typeof e)return s;const r=new os;return r.source=s,r.item=e,r.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=d(s),{source:o,item:t}=this;o.subscribeWith({onSubscribe:n,onSuccess:e,onError(s){let n;try{if(void 0===(n=t(s)))throw new Error(new Error("Single.onErrorReturn: returned an non-Single."))}catch(e){return void r([s,e])}e(n)}})}.bind(r),r};const Q=(s,e)=>{if(void 0===e)return s;const r=new os;return r.source=s,r.item=e,r.subscribeActual=function(s){const{onSuccess:e,onSubscribe:r}=d(s),{source:n,item:o}=this;n.subscribeWith({onSubscribe:r,onSuccess:e,onError(){e(o)}})}.bind(r),r};let V;const X=()=>(void 0===V&&((V=new os).subscribeActual=function(s){s.onSubscribe(o)}.bind(V)),V);const Y=(s,e)=>{const r=new os;return r.source=s,r.bipredicate=e,r.subscribeActual=function(s){const{onSubscribe:e,onSuccess:r,onError:n}=d(s),o=new u;e(o);const{source:t,bipredicate:i}=this;let c=0;const b=()=>{o.isDisposed()||(c+=1,t.subscribeWith({onSubscribe(s){o.setDisposable(s)},onSuccess:r,onError(s){"function"==typeof i?i(c,s)?b():n(s):b()}}))};b()}.bind(r),r};const Z=(s,e)=>{if(!(e instanceof os))return s;const r=new os;return r.source=s,r.other=e,r.subscribeActual=function(s){const{onSubscribe:e,onSuccess:r,onError:n}=d(s),o=new b;e(o);const{source:t,other:i}=this;o.isDisposed()||(i.subscribeWith({onSubscribe(s){o.add(s)},onSuccess(){n(new Error("Single.takeUntil: Source cancelled by other Single.")),o.dispose()},onError(s){n(new Error(["Single.takeUntil: Source cancelled by other Single.",s])),o.dispose()}}),t.subscribeWith({onSubscribe(s){o.add(s)},onSuccess(s){r(s),o.dispose()},onError(s){n(s),o.dispose()}}))}.bind(r),r};const $=s=>{if("number"!=typeof s)return U(new Error('Single.timer: "amount" is not a number.'));const e=new os;return e.amount=s,e.subscribeActual=function(s){const{onSuccess:e,onSubscribe:r}=d(s);let n;const o=new u(()=>{void 0!==n&&clearTimeout(n)});r(o),o.isDisposed()||(n=setTimeout(()=>{e(0),o.dispose()},this.amount))}.bind(e),e};const _=(s,e)=>{if("number"!=typeof e)return s;const r=new os;return r.source=s,r.amount=e,r.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=d(s),{amount:o}=this;let t;const i=new u(()=>{clearTimeout(t)}),c=s=>{r(s),i.dispose()};t=setTimeout(c,o,new Error("Single.timeout: TimeoutException (no success signals within the specified timeout).")),n(i),this.source.subscribeWith({onSubscribe(s){i.setDisposable(s)},onSuccess(s){e(s),i.dispose()},onError:c})}.bind(r),r},ss=s=>s;const es=(s,e)=>{if(!r(s))return U(new Error("Single.zip: sources is not Iterable."));let n=e;"function"!=typeof e&&(n=ss);const o=new os;return o.sources=s,o.zipper=n,o.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=d(s),o=[],t=new b;n(t);const{sources:i,zipper:c}=this,u=i.length;if(0===u)return r(new Error("Single.zip: empty iterable")),void t.dispose();let a=u;for(let s=0;s<u;s+=1){if(t.isDisposed())return;const n=i[s];if(n instanceof os)n.subscribeWith({onSubscribe(s){t.add(s)},onSuccess(n){if(!t.isDisposed()&&(o[s]=n,0==(a-=1))){let s;try{if(void 0===(s=c(o)))throw new Error("Single.zip: zipper function returned an undefined value.")}catch(s){return r(s),void t.dispose()}e(s),t.dispose()}},onError(s){t.isDisposed()||(r(s),t.dispose())}});else{if(void 0===n){r(new Error("Single.zip: One of the sources is undefined.")),t.dispose();break}o[s]=n,a-=1}}}.bind(o),o},rs=(s,e)=>[s,e];const ns=(s,e,r)=>{if(!(e instanceof os))return s;let n=r;"function"!=typeof r&&(n=rs);const o=new os;return o.source=s,o.other=e,o.zipper=n,o.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=d(s);let o,t;const i=new b;n(i);const{source:c,other:u,zipper:a}=this;c.subscribeWith({onSubscribe(s){i.add(s)},onSuccess(s){if(!i.isDisposed()&&(o=s,void 0!==t)){let s;try{if(void 0===(s=a(o,t)))throw new Error("Single.zipWith: zipper function returned an undefined value.")}catch(s){return r(s),void i.dispose()}e(s),i.dispose()}},onError(s){i.isDisposed()||(r(s),i.dispose())}}),u.subscribeWith({onSubscribe(s){i.add(s)},onSuccess(s){if(!i.isDisposed()&&(t=s,void 0!==o)){let s;try{if(void 0===(s=a(o,t)))throw new Error("Single.zipWith: zipper function returned an undefined value.")}catch(s){return r(s),void i.dispose()}e(s),i.dispose()}},onError(s){i.isDisposed()||(r(s),i.dispose())}})}.bind(o),o};class os{static create(s){return w(s)}static amb(s){return p(s)}ambWith(s){return S(this,s)}cache(){return E(this)}compose(s){return m(this,s)}contains(s,e){return v(this,s,e)}static defer(s){return D(s)}delay(s,e){return g(this,s,e)}delaySubscription(s){return A(this,s)}delayUntil(s){return W(this,s)}doAfterSuccess(s){return z(this,s)}doAfterTerminate(s){return T(this,s)}doFinally(s){return O(this,s)}doOnDispose(s){return P(this,s)}doOnError(s){return R(this,s)}doOnEvent(s){return j(this,s)}doOnSubscribe(s){return I(this,s)}doOnSuccess(s){return k(this,s)}doOnTerminate(s){return x(this,s)}static error(s){return U(s)}flatMap(s){return C(this,s)}static fromCallable(s){return M(s)}static fromPromise(s){return N(s)}static fromResolvable(s){return F(s)}static just(s){return q(s)}lift(s){return B(this,s)}map(s){return H(this,s)}static merge(s){return J(s)}static never(){return X()}onErrorResumeNext(s){return K(this,s)}onErrorReturn(s){return L(this,s)}onErrorReturnItem(s){return Q(this,s)}retry(s){return Y(this,s)}subscribeWith(s){n(s)&&this.subscribeActual(s)}subscribe(s,e){const r=new u;return this.subscribeActual({onSubscribe(s){r.setDisposable(s)},onSuccess:s,onError:e}),r}takeUntil(s){return Z(this,s)}static timer(s){return $(s)}timeout(s){return _(this,s)}static zip(s,e){return es(s,e)}zipWith(s,e){return ns(this,s,e)}toPromise(){return new Promise((s,e)=>{this.subscribe(s,e)})}then(s,e){return this.toPromise().then(s,e)}catch(s){return this.toPromise().catch(s)}}return os}();