var Single=function(){"use strict";const s=Symbol("DISPOSED"),e=s=>"object"==typeof s&&"function"==typeof s.dispose&&"function"==typeof s.isDisposed,r=s=>"object"==typeof s&&"function"==typeof s[Symbol.iterator],n=s=>"object"==typeof s&&"function"==typeof s.onSubscribe,o={dispose:()=>{},isDisposed:()=>!1},t=s=>s instanceof Promise||!!s&&("object"==typeof s||"function"==typeof s)&&"function"==typeof s.then;function i(s){if(!this.disposable.isDisposed())try{void 0===s?this.onError("onSuccess called with undefined."):this.onSuccess(s)}finally{this.disposable.dispose()}}function c(s){let e=s;if(void 0===s&&(e="onError called with undefined value."),!this.disposable.isDisposed())try{this.onError(e)}finally{this.disposable.dispose()}}class u{constructor(s){this.state=!1,this.onDispose=s}setDisposable(r){e(r)&&(this.state===s?r.dispose():this.state=r)}fire(){const{onDispose:e}=this;this.state=s,"function"==typeof e&&e(),this.onDispose=void 0}dispose(){const{state:r}=this;r!==s&&(e(r)?(r.isDisposed()||this.state.dispose(),r.isDisposed()&&this.fire()):this.fire())}isDisposed(){const{state:r}=this;return e(r)?!!r.isDisposed()&&(this.fire(),!0):r===s}}class b{constructor(){this.set=[],this.disposed=!1}add(s){e(s)&&(this.disposed?s.dispose():this.set.push(s))}dispose(){if(!this.disposed){for(const s of this.set)s.dispose();this.set=void 0,this.disposed=s}}isDisposed(){return this.disposed===s}}const a=(s,e)=>{const r=new u;s.onSubscribe(r),r.isDisposed()||(s.onSuccess(e),r.dispose())},l=(s,e)=>{const r=new u;s.onSubscribe(r),r.isDisposed()||(s.onError(e),r.dispose())};const d=s=>{if(!r(s))return k("Single.amb: sources is not Iterable.");const e=new es;return e.sources=s,e.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=s,o=new b;n(o);const{sources:t}=this,i=t.length;for(let s=0;s<i;s+=1){if(o.isDisposed())return;const n=t[s];if(!(n instanceof es)){r("Single.zip: One of the sources is a non-Single."),o.dispose();break}n.subscribeWith({onSubscribe(s){o.add(s)},onSuccess(s){e(s),o.dispose()},onError(s){r(s),o.dispose()}})}n(o)}.bind(e),e};const f=(s,e)=>{if(!(e instanceof es))return s;const r=new es;return r.source=s,r.other=e,r.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=s,o=new b;n(o);const{source:t,other:i}=this;t.subscribeWith({onSubscribe(s){o.add(s)},onSuccess(s){e(s),o.dispose()},onError(s){r(s),o.dispose()}}),i.subscribeWith({onSubscribe(s){o.add(s)},onSuccess(s){e(s),o.dispose()},onError(s){r(s),o.dispose()}})}.bind(r),r};const h=s=>{const e=new es;return e.source=s,e.cached=!1,e.subscribed=!1,e.observers=[],e.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=s,{source:o,cached:t,observers:i,subscribed:c}=this;if(t){const s=new u;n(s);const{value:o,error:t}=this;void 0!==o&&e(o),void 0!==t&&r(o),s.dispose()}else{const e=i.length;i[e]=s,n(new u(()=>{i.splice(e,1)})),c||(o.subscribeWith({onSubscribe(){},onSuccess:s=>{this.cached=!0,this.value=s;for(const e of i)e.onSuccess(s);this.observers=void 0},onError:s=>{this.cached=!0,this.error=s;for(const e of i)e.onError(s);this.observers=void 0}}),this.subscribed=!0)}}.bind(e),e};const p=s=>{if("function"!=typeof s)return k("Single.create: There are no subscribers.");const e=new es;return e.subscriber=s,e.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=s,o=new u;o.onSuccess=i.bind(this),o.onError=c.bind(this),this.disposable=o,this.onSuccess=e,this.onError=r,n(o);try{this.subscriber(o)}catch(s){o.onError(s)}}.bind(e),e},S=(s,e)=>{if("function"!=typeof e)return s;let r;try{if(!((r=e(s))instanceof es))throw new Error("Single.compose: transformer returned a non-Single.")}catch(s){r=k(s)}return r},E=(s,e)=>s===e;const w=(s,e,r)=>{if(void 0===e)return s;let n=r;"function"!=typeof n&&(n=E);const o=new es;return o.source=s,o.value=e,o.comparer=n,o.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=s,{value:o,comparer:t}=this;this.source.subscribeWith({onSubscribe:n,onSuccess(s){let n;try{n=t(s,o)}catch(s){return void r(s)}e(n)},onError:r})}.bind(o),o};const m=s=>{const e=new es;return e.supplier=s,e.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=s;let o,t;try{(o=this.supplier())instanceof es||(t="Single.defer: supplier returned a non-Single.")}catch(s){t=s}void 0!==t?l(s,t):o.subscribeWith({onSubscribe:n,onSuccess:e,onError:r})}.bind(e),e};const y=(s,e,r)=>{if("number"!=typeof e)return s;const n=new es;return n.source=s,n.amount=e,n.doDelayError=r,n.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=s;let o;const t=new u(()=>{void 0!==o&&clearTimeout(o)}),{amount:i,doDelayError:c}=this;n(t),this.source.subscribeWith({onSubscribe(s){t.setDisposable(s)},onSuccess(s){o=setTimeout(()=>{e(s),t.dispose()},i)},onError(s){o=setTimeout(()=>{r(s),t.dispose()},c?i:0)}})}.bind(n),n};const v=(s,e)=>{if("number"!=typeof e)return s;const r=new es;return r.source=s,r.amount=e,r.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=s,{amount:o}=this;let t;const i=new u(()=>{void 0!==t&&clearTimeout(t)});n(i),t=setTimeout(()=>{this.source.subscribeWith({onSubscribe(s){i.setDisposable(s)},onSuccess(s){e(s),i.dispose()},onError(s){r(s),i.dispose()}})},o)}.bind(r),r};const D=(s,e)=>{if(!(e instanceof es))return s;const r=new es;return r.source=s,r.other=e,r.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=s,{source:o,other:t}=this,i=new u;n(i),t.subscribeWith({onSubscribe(s){i.setDisposable(s)},onSuccess(){i.isDisposed()||o.subscribeWith({onSubscribe(s){i.setDisposable(s)},onSuccess(s){e(s),i.dispose()},onError(s){r(s),i.dispose()}})},onError(s){r(s),i.dispose()}})}.bind(r),r};const g=(s,e)=>{if("function"!=typeof e)return s;const r=new es;return r.source=s,r.callable=e,r.subscribeActual=function(s){const{onSubscribe:e,onSuccess:r,onError:n}=s,{source:o,callable:t}=this;o.subscribeWith({onSubscribe:e,onSuccess(s){r(s),t(s)},onError:n})}.bind(r),r};const A=(s,e)=>{if("function"!=typeof e)return s;const r=new es;return r.source=s,r.callable=e,r.subscribeActual=function(s){const{onSubscribe:e,onSuccess:r,onError:n}=s,{source:o,callable:t}=this;o.subscribeWith({onSubscribe:e,onSuccess(s){r(s),t()},onError(s){n(s),t()}})}.bind(r),r};const W=(s,e)=>{if("function"!=typeof e)return s;const r=new es;return r.source=s,r.callable=e,r.subscribeActual=function(s){const{onSubscribe:e,onSuccess:r,onError:n}=s,{source:o,callable:t}=this;let i=!1;const c=new u(()=>{i||(t(),i=!0)});o.subscribeWith({onSubscribe(s){c.setDisposable(s),e(c)},onSuccess(s){r(s),i||(t(),i=!0)},onError(s){n(s),i||(t(),i=!0)}})}.bind(r),r};const z=(s,e)=>{if("function"!=typeof e)return s;const r=new es;return r.source=s,r.callable=e,r.subscribeActual=function(s){const{onSubscribe:e,onSuccess:r,onError:n}=s,{source:o,callable:t}=this,i=new u(t);e(i),o.subscribeWith({onSubscribe(s){i.setDisposable(s)},onSuccess(s){r(s),i.dispose()},onError(s){n(s),i.dispose()}})}.bind(r),r};const T=(s,e)=>{if("function"!=typeof e)return s;const r=new es;return r.source=s,r.callable=e,r.subscribeActual=function(s){const{onSubscribe:e,onSuccess:r,onError:n}=s,{source:o,callable:t}=this;o.subscribeWith({onSubscribe:e,onSuccess:r,onError(s){t(s),n(s)}})}.bind(r),r};const O=(s,e)=>{if("function"!=typeof e)return s;const r=new es;return r.source=s,r.callable=e,r.subscribeActual=function(s){const{onSubscribe:e,onSuccess:r,onError:n}=s,{source:o,callable:t}=this;o.subscribeWith({onSubscribe:e,onSuccess(s){t(s),r(s)},onError(s){t(void 0,s),n(s)}})}.bind(r),r};const P=(s,e)=>{if("function"!=typeof e)return s;const r=new es;return r.source=s,r.callable=e,r.subscribeActual=function(s){const{onSubscribe:e,onSuccess:r,onError:n}=s,{source:o,callable:t}=this;o.subscribeWith({onSubscribe:e,onSuccess(s){t(s),r(s)},onError:n})}.bind(r),r};const R=(s,e)=>{if("function"!=typeof e)return s;const r=new es;return r.source=s,r.callable=e,r.subscribeActual=function(s){const{onSubscribe:e,onSuccess:r,onError:n}=s,{source:o,callable:t}=this;o.subscribeWith({onSubscribe(s){t(s),e(s)},onSuccess:r,onError:n})}.bind(r),r};const j=(s,e)=>{if("function"!=typeof e)return s;const r=new es;return r.source=s,r.callable=e,r.subscribeActual=function(s){const{onSubscribe:e,onSuccess:r,onError:n}=s,{source:o,callable:t}=this;o.subscribeWith({onSubscribe:e,onSuccess(s){t(),r(s)},onError(s){t(),n(s)}})}.bind(r),r};const k=s=>{let e=s;void 0===s&&(e="Single.error received an undefined value."),"function"!=typeof s&&(e=(s=>()=>s)(e));const r=new es;return r.supplier=e,r.subscribeActual=function(s){let e;try{void 0===(e=this.supplier())&&(e="Single.error: Error supplier returned an undefined value.")}catch(s){e=s}l(s,e)}.bind(r),r};const I=(s,e)=>{if("function"!=typeof e)return s;const r=new es;return r.source=s,r.mapper=e,r.subscribeActual=function(s){const{onSubscribe:e,onError:r,onSuccess:n}=s,o=new u;e(o);const{mapper:t,source:i}=this;i.subscribeWith({onSubscribe(s){o.setDisposable(s)},onSuccess(s){let e;try{if(!((e=t(s))instanceof es))throw new Error("Single.flatMap: mapper returned a non-Single")}catch(s){return void r(s)}e.subscribeWith({onSubscribe(s){o.setDisposable(s)},onSuccess:n,onError:r})},onError:r})}.bind(r),r};const x=s=>{if("function"!=typeof s)return k("Single.fromCallable: callable received is not a function.");const e=new es;return e.callable=s,e.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=s,o=new u;n(o),this.disposable=o,this.onSuccess=e,this.onError=r;const b=i.bind(this),a=c.bind(this);let l;try{l=this.callable()}catch(s){return void a(s)}t(l)?U(l).subscribe(e,r):b(l)}.bind(e),e};const U=s=>{if(!t(s))return k("Single.fromPromise: expects a Promise-like value.");const e=new es;return e.promise=s,e.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=s,o=new u;n(o),this.disposable=o,this.onSuccess=e,this.onError=r,this.promise.then(i.bind(this),c.bind(this))}.bind(e),e};const C=s=>{if("function"!=typeof s)return k("Single.fromResolvable: There are no subscribers.");const e=new es;return e.subscriber=s,e.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=s,o=new u;n(o),this.disposable=o,this.onSuccess=e,this.onError=r;const t=i.bind(this),b=c.bind(this);this.subscriber(t,b)}.bind(e),e};const M=s=>{if(void 0===s)return k("Single.just: received an undefined value.");const e=new es;return e.value=s,e.subscribeActual=function(s){a(s,this.value)}.bind(e),e};const N=(s,e)=>{if("function"!=typeof e)return s;const r=new es;return r.source=s,r.operator=e,r.subscribeActual=function(s){let e;try{if(e=this.operator(s),!n(e))throw new Error("Single.lift: operator returned a non-Observer.")}catch(e){return void l(s,e)}this.source.subscribeWith(e)}.bind(r),r},F=s=>s;const q=(s,e)=>{let r=e;"function"!=typeof e&&(r=F);const n=new es;return n.source=s,n.mapper=r,n.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=s,{mapper:o}=this;this.source.subscribeWith({onSubscribe:n,onSuccess(s){let n;try{if(void 0===(n=o(s)))throw new Error("Single.map: mapper function returned an undefined value.")}catch(s){return void r(s)}e(n)},onError:r})}.bind(n),n};const B=s=>{if(!(s instanceof es))return k("Single.merge: source is not a Single.");const e=new es;return e.source=s,e.subscribeActual=function(s){const{onSubscribe:e,onError:r,onSuccess:n}=s,o=new u;e(o),this.source.subscribeWith({onSubscribe(s){o.setDisposable(s)},onSuccess(s){let e=s;s instanceof es||(e=k("Single.merge: source emitted a non-Single value.")),e.subscribeWith({onSubscribe(s){o.setDisposable(s)},onSuccess:n,onError:r})},onError:r})}.bind(e),e};const G=(s,e)=>{if(!("function"==typeof e||e instanceof es))return s;const r=new es;return r.source=s,r.resumeIfError=e,r.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=s,{source:o,resumeIfError:t}=this,i=new u;n(i),o.subscribeWith({onSubscribe(s){i.setDisposable(s)},onSuccess:e,onError(s){let n;if("function"==typeof t)try{if(void 0===(n=t(s)))throw new Error("Single.onErrorResumeNext: returned an non-Single.")}catch(e){return void r([s,e])}else n=t;n.subscribeWith({onSubscribe(s){i.setDisposable(s)},onSuccess:e,onError:r})}})}.bind(r),r};const H=(s,e)=>{if("function"!=typeof e)return s;const r=new es;return r.source=s,r.item=e,r.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=s,{source:o,item:t}=this;o.subscribeWith({onSubscribe:n,onSuccess:e,onError(s){let n;try{if(void 0===(n=t(s)))throw new Error("Single.onErrorReturn: returned an non-Single.")}catch(e){return void r([s,e])}e(n)}})}.bind(r),r};const J=(s,e)=>{if(void 0===e)return s;const r=new es;return r.source=s,r.item=e,r.subscribeActual=function(s){const{onSuccess:e,onSubscribe:r}=s,{source:n,item:o}=this;n.subscribeWith({onSubscribe:r,onSuccess:e,onError(){e(o)}})}.bind(r),r};let K;const L=()=>(void 0===K&&((K=new es).subscribeActual=function(s){s.onSubscribe(o)}.bind(K)),K);const Q=(s,e)=>{const r=new es;return r.source=s,r.bipredicate=e,r.subscribeActual=function(s){const{onSubscribe:e,onSuccess:r,onError:n}=s,o=new u;e(o);const{source:t,bipredicate:i}=this;let c=0;const b=()=>{o.isDisposed()||(c+=1,t.subscribeWith({onSubscribe(s){o.setDisposable(s)},onSuccess:r,onError(s){"function"==typeof i?i(c,s)?b():n(s):b()}}))};b()}.bind(r),r};const V=(s,e)=>{if(!(e instanceof es))return s;const r=new es;return r.source=s,r.other=e,r.subscribeActual=function(s){const{onSubscribe:e,onSuccess:r,onError:n}=s,o=new b;e(o);const{source:t,other:i}=this;o.isDisposed()||(i.subscribeWith({onSubscribe(s){o.add(s)},onSuccess(){n("Single.takeUntil: Source cancelled by other Single."),o.dispose()},onError(s){n(["Single.takeUntil: Source cancelled by other Single.",s]),o.dispose()}}),t.subscribeWith({onSubscribe(s){o.add(s)},onSuccess(s){r(s),o.dispose()},onError(s){n(s),o.dispose()}}))}.bind(r),r};const X=s=>{if("number"!=typeof s)return k('Single.timer: "amount" is not a number.');const e=new es;return e.amount=s,e.subscribeActual=function(s){const{onSuccess:e,onSubscribe:r}=s;let n;const o=new u(()=>{void 0!==n&&clearTimeout(n)});r(o),o.isDisposed()||(n=setTimeout(()=>{e(0),o.dispose()},this.amount))}.bind(e),e};const Y=(s,e)=>{if("number"!=typeof e)return s;const r=new es;return r.source=s,r.amount=e,r.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=s,{amount:o}=this;let t;const i=new u(()=>{clearTimeout(t)}),c=s=>{r(s),i.dispose()};t=setTimeout(c,o,"Single.timeout: TimeoutException (no success signals within the specified timeout)."),n(i),this.source.subscribeWith({onSubscribe(s){i.setDisposable(s)},onSuccess(s){e(s),i.dispose()},onError:c})}.bind(r),r},Z=s=>s;const $=(s,e)=>{if(!r(s))return k("Single.zip: sources is not Iterable.");let n=e;"function"!=typeof e&&(n=Z);const o=new es;return o.sources=s,o.zipper=n,o.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=s,o=[],t=new b;n(t);const{sources:i,zipper:c}=this,u=i.length;if(0===u)return r("Single.zip: empty iterable"),void t.dispose();let a=u;for(let s=0;s<u;s+=1){if(t.isDisposed())return;const n=i[s];if(n instanceof es)n.subscribeWith({onSubscribe(s){t.add(s)},onSuccess(n){if(!t.isDisposed()&&(o[s]=n,0==(a-=1))){let s;try{if(void 0===(s=c(o)))throw new Error("Single.zip: zipper function returned an undefined value.")}catch(s){return r(s),void t.dispose()}e(s),t.dispose()}},onError(s){t.isDisposed()||(r(s),t.dispose())}});else{if(void 0===n){r("Single.zip: One of the sources is undefined."),t.dispose();break}o[s]=n,a-=1}}}.bind(o),o},_=(s,e)=>[s,e];const ss=(s,e,r)=>{if(!(e instanceof es))return s;let n=r;"function"!=typeof r&&(n=_);const o=new es;return o.source=s,o.other=e,o.zipper=n,o.subscribeActual=function(s){const{onSuccess:e,onError:r,onSubscribe:n}=s;let o,t;const i=new b;n(i);const{source:c,other:u,zipper:a}=this;c.subscribeWith({onSubscribe(s){i.add(s)},onSuccess(s){if(!i.isDisposed()&&(o=s,void 0!==t)){let s;try{if(void 0===(s=a(o,t)))throw new Error("Single.zipWith: zipper function returned an undefined value.")}catch(s){return r(s),void i.dispose()}e(s),i.dispose()}},onError(s){i.isDisposed()||(r(s),i.dispose())}}),u.subscribeWith({onSubscribe(s){i.add(s)},onSuccess(s){if(!i.isDisposed()&&(t=s,void 0!==o)){let s;try{if(void 0===(s=a(o,t)))throw new Error("Single.zipWith: zipper function returned an undefined value.")}catch(s){return r(s),void i.dispose()}e(s),i.dispose()}},onError(s){i.isDisposed()||(r(s),i.dispose())}})}.bind(o),o};class es{static create(s){return p(s)}static amb(s){return d(s)}ambWith(s){return f(this,s)}cache(){return h(this)}compose(s){return S(this,s)}contains(s,e){return w(this,s,e)}static defer(s){return m(s)}delay(s,e){return y(this,s,e)}delaySubscription(s){return v(this,s)}delayUntil(s){return D(this,s)}doAfterSuccess(s){return g(this,s)}doAfterTerminate(s){return A(this,s)}doFinally(s){return W(this,s)}doOnDispose(s){return z(this,s)}doOnError(s){return T(this,s)}doOnEvent(s){return O(this,s)}doOnSubscribe(s){return R(this,s)}doOnSuccess(s){return P(this,s)}doOnTerminate(s){return j(this,s)}static error(s){return k(s)}flatMap(s){return I(this,s)}static fromCallable(s){return x(s)}static fromPromise(s){return U(s)}static fromResolvable(s){return C(s)}static just(s){return M(s)}lift(s){return N(this,s)}map(s){return q(this,s)}static merge(s){return B(s)}static never(){return L()}onErrorResumeNext(s){return G(this,s)}onErrorReturn(s){return H(this,s)}onErrorReturnItem(s){return J(this,s)}retry(s){return Q(this,s)}subscribeWith(s){n(s)&&this.subscribeActual(s)}subscribe(s,e){const r=new u;return this.subscribeActual({onSubscribe(s){r.setDisposable(s)},onSuccess:s,onError:e}),r}takeUntil(s){return V(this,s)}static timer(s){return X(s)}timeout(s){return Y(this,s)}static zip(s,e){return $(s,e)}zipWith(s,e){return ss(this,s,e)}toPromise(){return new Promise((s,e)=>{this.subscribe(s,e)})}then(s,e){return this.toPromise().then(s,e)}catch(s){return this.toPromise().catch(s)}}return es}();