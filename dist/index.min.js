var Single=function(r,e){"use strict";r=r&&r.hasOwnProperty("default")?r.default:r,e=e&&e.hasOwnProperty("default")?e.default:e;const n=(r,e)=>typeof r===e,o=r=>n(r,"function"),t=r=>n(r,"number"),s=r=>n(r,"object"),c=r=>s(r)&&o(r[Symbol.iterator]),i=r=>s(r)&&o(r.onSubscribe),u=r=>null!=r&&(r instanceof Promise||(s(r)||o(r))&&o(r.then));function b(r){const{onSuccess:e,onError:n,controller:o}=this;if(!o.signal.aborted)try{void 0===r?n(new Error("onSuccess called with a null value.")):e(r)}finally{o.abort()}}function a(r){const{onError:e,controller:n}=this;let o=r;if(r instanceof Error||(o=new Error("onError called with a non-Error value.")),!n.signal.aborted)try{e(o)}finally{n.abort()}}const l=r=>r,h=r=>{throw r},S=r=>({onSubscribe:r.onSubscribe,onSuccess:o(r.onSuccess)?r.onSuccess:l,onError:o(r.onError)?r.onError:h}),d=(e,n)=>{const{onSubscribe:o,onSuccess:t}=S(e),s=new r;o(s),s.signal.aborted||(t(n),s.abort())},f=(e,n)=>{const{onSubscribe:o,onError:t}=S(e),s=new r;o(s),s.signal.aborted||(t(n),s.abort())};function E(r){let e;try{if(null==(e=this.supplier()))throw new Error("Single.error: Error supplier returned a null value.")}catch(r){e=r}f(r,e)}var v=r=>{let e=r;r instanceof Error||o(r)||(e=new Error("Single.error received a non-Error value.")),o(r)||(e=(r=>()=>r)(e));const n=new Qr(E);return n.supplier=e,n};function w(e){const{onSuccess:n,onError:o,onSubscribe:t}=S(e),s=new r,{signal:c}=s;if(t(s),c.aborted)return;const{sources:i}=this;for(const r of i){if(c.aborted)return;if(!(r instanceof Qr)){o(new Error("Single.amb: One of the sources is a non-Single.")),s.abort();break}r.subscribeWith({onSubscribe(r){c.addEventListener("abort",()=>r.abort())},onSuccess(r){n(r),s.abort()},onError(r){o(r),s.abort()}})}}var g=r=>{if(!c(r))return v(new Error("Single.amb: sources is not Iterable."));const e=new Qr(w);return e.sources=r,e};function p(e){const{onSuccess:n,onError:o,onSubscribe:t}=S(e),s=new r,{signal:c}=s;if(t(s),c.aborted)return;const i=r=>{c.aborted||(n(r),s.abort())},u=r=>{c.aborted||(o(r),s.abort())},{source:b,other:a}=this;b.subscribeWith({onSubscribe(r){c.addEventListener("abort",()=>r.abort())},onSuccess:i,onError:u}),a.subscribeWith({onSubscribe(r){c.aborted?r.abort():c.addEventListener("abort",()=>r.abort())},onSuccess:i,onError:u})}var m=(r,e)=>{if(!(e instanceof Qr))return r;const n=new Qr(p);return n.source=r,n.other=e,n};function W(e){const{onSuccess:n,onError:o,onSubscribe:t}=S(e),{source:s,cached:c,observers:i,subscribed:u}=this;if(c){const e=new r;t(e);const{value:s,error:c}=this;null!=s&&n(s),null!=c&&o(c),e.abort()}else{const n=i.length;i[n]=e;const o=new r;o.signal.addEventListener("abort",()=>{i.splice(n,1)}),t(o),u||(s.subscribeWith({onSubscribe(){},onSuccess:r=>{this.cached=!0,this.value=r;for(const e of i)e.onSuccess(r);this.observers=void 0},onError:r=>{this.cached=!0,this.error=r;for(const e of i)e.onError(r);this.observers=void 0}}),this.subscribed=!0)}}var y=r=>{const e=new Qr(W);return e.source=r,e.cached=!1,e.subscribed=!1,e.observers=[],e};function L(e){const{onSuccess:n,onError:o,onSubscribe:t}=S(e),s=new r;s.onSuccess=b.bind(this),s.onError=a.bind(this),this.controller=s,this.onSuccess=n,this.onError=o,t(s);try{this.subscriber(s)}catch(r){s.onError(r)}}var z=r=>{if("function"!=typeof r)return v(new Error("Single.create: There are no subscribers."));const e=new Qr(L);return e.subscriber=r,e},O=(r,e)=>{if(!o(e))return r;let n;try{if(!((n=e(r))instanceof Qr))throw new Error("Single.compose: transformer returned a non-Single.")}catch(r){n=v(r)}return n};const P=(r,e)=>r===e;function A(r){const{onSuccess:e,onError:n,onSubscribe:o}=S(r),{value:t,comparer:s}=this;this.source.subscribeWith({onSubscribe:o,onSuccess(r){let o;try{o=s(r,t)}catch(r){return void n(r)}e(o)},onError:n})}var R=(r,e,n)=>{if(null==e)return r;let t=n;o(t)||(t=P);const s=new Qr(A);return s.source=r,s.value=e,s.comparer=t,s};function k(r){const{onSuccess:e,onError:n,onSubscribe:o}=S(r);let t,s;try{if(!((t=this.supplier())instanceof Qr))throw new Error("Single.defer: supplier returned a non-Single.")}catch(r){s=r}null!=s?f(r,s):t.subscribeWith({onSubscribe:o,onSuccess:e,onError:n})}var x=r=>{const e=new Qr(k);return e.supplier=r,e};function I(e){const{onSuccess:n,onError:o,onSubscribe:t}=S(e),{amount:s,scheduler:c,doDelayError:i}=this,u=new r,{signal:b}=u;t(u),b.aborted||this.source.subscribeWith({onSubscribe(r){b.addEventListener("abort",()=>{r.abort()})},onSuccess(r){const e=c.delay(()=>{n(r),u.abort()},s);b.addEventListener("abort",()=>{e.abort()})},onError(r){const e=c.delay(()=>{o(r),u.abort()},i?s:0);b.addEventListener("abort",()=>{e.abort()})}})}var T=(r,n,o,s)=>{if(!t(n))return r;let c=o;c instanceof e.interface||(c=e.current);const i=new Qr(I);return i.source=r,i.amount=n,i.scheduler=c,i.doDelayError=s,i};function U(e){const{onSuccess:n,onError:o,onSubscribe:t}=S(e),{amount:s,scheduler:c}=this,i=new r,{signal:u}=i;if(t(i),u.aborted)return;const b=c.delay(()=>{this.source.subscribeWith({onSubscribe(r){u.addEventListener("abort",()=>r.abort())},onSuccess(r){n(r),i.abort()},onError(r){o(r),i.abort()}})},s);u.addEventListener("abort",()=>b.abort())}var j=(r,n,o)=>{if(!t(n))return r;let s=o;s instanceof e.interface||(s=e.current);const c=new Qr(U);return c.source=r,c.amount=n,c.scheduler=s,c};function C(e){const{onSuccess:n,onError:o,onSubscribe:t}=S(e),{source:s,other:c}=this,i=new r,{signal:u}=i;t(i),u.aborted||c.subscribeWith({onSubscribe(r){u.addEventListener("abort",()=>r.abort())},onSuccess(){u.aborted||s.subscribeWith({onSubscribe(r){u.addEventListener("abort",()=>r.abort())},onSuccess(r){n(r),i.abort()},onError(r){o(r),i.abort()}})},onError(r){o(r),i.abort()}})}var D=(r,e)=>{if(!(e instanceof Qr))return r;const n=new Qr(C);return n.source=r,n.other=e,n};function M(r){const{onSuccess:e,onError:n,onSubscribe:o}=S(r),{source:t,callable:s}=this;t.subscribeWith({onSubscribe:o,onSuccess(r){e(r),s(r)},onError:n})}var N=(r,e)=>{if(!o(e))return r;const n=new Qr(M);return n.source=r,n.callable=e,n};function F(r){const{onSuccess:e,onError:n,onSubscribe:o}=S(r),{source:t,callable:s}=this;t.subscribeWith({onSubscribe:o,onSuccess(r){e(r),s()},onError(r){n(r),s()}})}var q=(r,e)=>{if(!o(e))return r;const n=new Qr(F);return n.source=r,n.callable=e,n};function B(r){const{onSuccess:e,onError:n,onSubscribe:o}=S(r),{source:t,callable:s}=this;let c=!1;t.subscribeWith({onSubscribe(r){r.signal.addEventListener("abort",()=>{c||(s(),c=!0)}),o(r)},onSuccess(r){e(r),c||(s(),c=!0)},onError(r){n(r),c||(s(),c=!0)}})}var G=(r,e)=>{if(!o(e))return r;const n=new Qr(B);return n.source=r,n.callable=e,n};function H(r){const{onSuccess:e,onError:n,onSubscribe:o}=S(r),{source:t,callable:s}=this;t.subscribeWith({onSubscribe(r){r.signal.addEventListener("abort",s),o(r)},onSuccess:e,onError:n})}var J=(r,e)=>{if(!o(e))return r;const n=new Qr(H);return n.source=r,n.callable=e,n};function K(r){const{onSuccess:e,onError:n,onSubscribe:o}=S(r),{source:t,callable:s}=this;t.subscribeWith({onSubscribe:o,onSuccess:e,onError(r){s(r),n(r)}})}var Q=(r,e)=>{if(!o(e))return r;const n=new Qr(K);return n.source=r,n.callable=e,n};function V(r){const{onSuccess:e,onError:n,onSubscribe:o}=S(r),{source:t,callable:s}=this;t.subscribeWith({onSubscribe:o,onSuccess(r){s(r),e(r)},onError(r){s(void 0,r),n(r)}})}var X=(r,e)=>{if(!o(e))return r;const n=new Qr(V);return n.source=r,n.callable=e,n};function Y(r){const{onSuccess:e,onError:n,onSubscribe:o}=S(r),{source:t,callable:s}=this;t.subscribeWith({onSubscribe:o,onSuccess(r){s(r),e(r)},onError:n})}var Z=(r,e)=>{if(!o(e))return r;const n=new Qr(Y);return n.source=r,n.callable=e,n};function $(r){const{onSuccess:e,onError:n,onSubscribe:o}=S(r),{source:t,callable:s}=this;t.subscribeWith({onSubscribe(r){s(r),o(r)},onSuccess:e,onError:n})}var _=(r,e)=>{if(!o(e))return r;const n=new Qr($);return n.source=r,n.callable=e,n};function rr(r){const{onSuccess:e,onError:n,onSubscribe:o}=S(r),{source:t,callable:s}=this;t.subscribeWith({onSubscribe:o,onSuccess(r){s(),e(r)},onError(r){s(),n(r)}})}var er=(r,e)=>{if(!o(e))return r;const n=new Qr(rr);return n.source=r,n.callable=e,n};function nr(e){const{onSubscribe:n,onError:o,onSuccess:t}=S(e),s=new r,{signal:c}=s;if(n(s),c.aborted)return;const{mapper:i,source:u}=this;u.subscribeWith({onSubscribe(r){c.addEventListener("abort",()=>r.abort())},onSuccess(r){let e;try{if(!((e=i(r))instanceof Qr))throw new Error("Single.flatMap: mapper returned a non-Single")}catch(r){return void o(r)}e.subscribeWith({onSubscribe(r){c.addEventListener("abort",()=>r.abort())},onSuccess(r){t(r),s.abort()},onError(r){o(r),s.abort()}})},onError(r){o(r),s.abort()}})}var or=(r,e)=>{if(!o(e))return r;const n=new Qr(nr);return n.source=r,n.mapper=e,n};function tr(e){const{onSuccess:n,onError:o,onSubscribe:t}=S(e),s=new r;if(t(s),s.signal.aborted)return;this.controller=s,this.onSuccess=n,this.onError=o;const c=b.bind(this),i=a.bind(this);let l;try{l=this.callable()}catch(r){return void i(r)}u(l)?ir(l).subscribeWith({onSubscribe(r){s.signal.addEventListener("abort",()=>r.abort())},onSuccess:c,onError:i}):c(l)}var sr=r=>{if(!o(r))return v(new Error("Single.fromCallable: callable received is not a function."));const e=new Qr(tr);return e.callable=r,e};function cr(e){const{onSuccess:n,onError:o,onSubscribe:t}=S(e),s=new r;t(s),s.signal.aborted||(this.controller=s,this.onSuccess=n,this.onError=o,this.promise.then(b.bind(this),a.bind(this)))}var ir=r=>{if(!u(r))return v(new Error("Single.fromPromise: expects a Promise-like value."));const e=new Qr(cr);return e.promise=r,e};function ur(e){const{onSuccess:n,onError:o,onSubscribe:t}=S(e),s=new r;if(t(s),s.signal.aborted)return;this.controller=s,this.onSuccess=n,this.onError=o;const c=b.bind(this),i=a.bind(this);this.subscriber(c,i)}var br=r=>{if(!o(r))return v(new Error("Single.fromResolvable: expects a function."));const e=new Qr(ur);return e.subscriber=r,e};function ar(r){d(r,this.value)}var lr=r=>{if(null==r)return v(new Error("Single.just: received a null value."));const e=new Qr(ar);return e.value=r,e};function hr(r){let e;try{if(e=this.operator(r),!i(e))throw new Error("Single.lift: operator returned a non-Observer.")}catch(e){return void f(r,e)}this.source.subscribeWith(e)}var Sr=(r,e)=>{if(!o(e))return r;const n=new Qr(hr);return n.source=r,n.operator=e,n};const dr=r=>r;function fr(r){const{onSuccess:e,onError:n,onSubscribe:o}=S(r),{mapper:t}=this;this.source.subscribeWith({onSubscribe:o,onSuccess(r){let o;try{if(null==(o=t(r)))throw new Error("Single.map: mapper function returned a null value.")}catch(r){return void n(r)}e(o)},onError:n})}var Er=(r,e)=>{let n=e;o(e)||(n=dr);const t=new Qr(fr);return t.source=r,t.mapper=n,t};function vr(e){const{onSubscribe:n,onError:o,onSuccess:t}=S(e),s=new r,{signal:c}=s;n(s),c.aborted||this.source.subscribeWith({onSubscribe(r){c.addEventListener("abort",()=>r.abort())},onSuccess(r){let e=r;r instanceof Qr||(e=v(new Error("Single.merge: source emitted a non-Single value."))),e.subscribeWith({onSubscribe(r){c.addEventListener("abort",()=>r.abort())},onSuccess(r){t(r),s.abort()},onError(r){o(r),s.abort()}})},onError(r){o(r),s.abort()}})}var wr=r=>{if(!(r instanceof Qr))return v(new Error("Single.merge: source is not a Single."));const e=new Qr(vr);return e.source=r,e};function gr(e){const{onSubscribe:n,onSuccess:o,onError:t}=S(e),{source:s,scheduler:c}=this,i=new r;n(i);const{signal:u}=i;u.aborted||s.subscribeWith({onSubscribe(r){u.addEventListener("abort",()=>r.abort())},onSuccess(r){c.schedule(()=>{o(r),i.abort()})},onError(r){c.schedule(()=>{t(r),i.abort()})}})}var pr=(r,n)=>{let o=n;o instanceof e.interface||(o=e.current);const t=new Qr(gr);return t.source=r,t.scheduler=o,t};function mr(e){const{onSuccess:n,onError:t,onSubscribe:s}=S(e),{source:c,resumeIfError:i}=this,u=new r,{signal:b}=u;s(u),b.aborted||c.subscribeWith({onSubscribe(r){b.addEventListener("abort",()=>r.abort())},onSuccess(r){n(r),u.abort()},onError(r){let e;if(o(i))try{if(!((e=i(r))instanceof Qr))throw new Error("Single.onErrorResumeNext: returned an non-Single.")}catch(e){return void t(new Error([r,e]))}else e=i;e.subscribeWith({onSubscribe(r){b.addEventListener("abort",()=>r.abort())},onSuccess(r){n(r),u.abort()},onError(r){t(r),u.abort()}})}})}var Wr=(r,e)=>{if(!(o(e)||e instanceof Qr))return r;const n=new Qr(mr);return n.source=r,n.resumeIfError=e,n};function yr(r){const{onSuccess:e,onError:n,onSubscribe:o}=S(r),{source:t,item:s}=this;t.subscribeWith({onSubscribe:o,onSuccess:e,onError(r){let o;try{if(null==(o=s(r)))throw new Error(new Error("Single.onErrorReturn: returned a null value."))}catch(e){return void n([r,e])}e(o)}})}var Lr=(r,e)=>{if(!o(e))return r;const n=new Qr(yr);return n.source=r,n.item=e,n};function zr(r){const{onSuccess:e,onSubscribe:n}=S(r),{source:o,item:t}=this;o.subscribeWith({onSubscribe:n,onSuccess:e,onError(){e(t)}})}var Or=(r,e)=>{if(null==e)return r;const n=new Qr(zr);return n.source=r,n.item=e,n};const Pr={signal:{aborted:!1,addEventListener:()=>{},removeEventListener:()=>{},onabort:()=>{}},abort:()=>{}};function Ar(r){r.onSubscribe(Pr)}let Rr;var kr=()=>(void 0===Rr&&((Rr=new Qr(Ar)).subscribeActual=Ar.bind(Rr)),Rr);function xr(e){const{onSubscribe:n,onSuccess:t,onError:s}=S(e),c=new r,{signal:i}=c;if(n(c),i.aborted)return;const{source:u,bipredicate:b}=this;let a=0;const l=()=>{i.aborted||(a+=1,u.subscribeWith({onSubscribe(r){i.addEventListener("abort",()=>r.abort())},onSuccess(r){t(r),c.abort()},onError(r){if(o(b)){b(a,r)?l():(s(r),c.abort())}else l()}}))};l()}var Ir=(r,e)=>{const n=new Qr(xr);return n.source=r,n.bipredicate=e,n};function Tr(e){const{onSubscribe:n,onSuccess:o,onError:t}=S(e),{source:s,scheduler:c}=this,i=new r;n(i);const{signal:u}=i;u.aborted||c.schedule(()=>{u.aborted||s.subscribeWith({onSubscribe(r){u.addEventListener("abort",()=>r.abort())},onSuccess(r){o(r),i.abort()},onError(r){t(r),i.abort()}})})}var Ur=(r,n)=>{let o=n;o instanceof e.interface||(o=e.current);const t=new Qr(Tr);return t.source=r,t.scheduler=o,t};function jr(e){const{onSubscribe:n,onSuccess:o,onError:t}=S(e),s=new r,{signal:c}=s;if(n(s),c.aborted)return;const{source:i,other:u}=this;u.subscribeWith({onSubscribe(r){c.addEventListener("abort",()=>r.abort())},onSuccess(){t(new Error("Single.takeUntil: Source cancelled by other Single.")),s.abort()},onError(r){t(new Error(["Single.takeUntil: Source cancelled by other Single.",r])),s.abort()}}),i.subscribeWith({onSubscribe(r){c.aborted?r.abort():c.addEventListener("abort",()=>r.abort())},onSuccess(r){o(r),s.abort()},onError(r){t(r),s.abort()}})}const Cr=(r,e)=>{if(!(e instanceof Qr))return r;const n=new Qr(jr);return n.source=r,n.other=e,n};function Dr(e){const{onSuccess:n,onSubscribe:o}=S(e),t=new r,{signal:s}=t;if(o(t),s.aborted)return;const c=this.scheduler.delay(()=>n(0),this.amount);s.addEventListener("abort",()=>c.abort())}var Mr=(r,n)=>{if(!t(r))return v(new Error('Single.timer: "amount" is not a number.'));let o=n;o instanceof e.interface||(o=e.current);const s=new Qr(Dr);return s.amount=r,s.scheduler=o,s};function Nr(e){const{onSuccess:n,onError:o,onSubscribe:t}=S(e),{amount:s,scheduler:c}=this,i=new r,{signal:u}=i;if(t(i),u.aborted)return;const b=c.delay(()=>{o(new Error("Single.timeout: TimeoutException (no success signals within the specified timeout).")),i.abort()},s);u.addEventListener("abort",()=>b.abort()),this.source.subscribeWith({onSubscribe(r){u.addEventListener("abort",()=>r.abort())},onSuccess(r){n(r),i.abort()},onError(r){o(r),i.abort()}})}var Fr=(r,n,o)=>{if(!t(n))return r;let s=o;s instanceof e.interface||(s=e.current);const c=new Qr(Nr);return c.source=r,c.amount=n,c.scheduler=s,c};const qr=r=>r;function Br(e){const{onSuccess:n,onError:o,onSubscribe:t}=S(e),s=[],c=new r,{signal:i}=c;if(t(c),i.aborted)return;const{sources:u,zipper:b}=this,a=u.length;if(0===a)return o(new Error("Single.zip: empty iterable")),void c.abort();let l=a;for(let r=0;r<a;r+=1){if(i.aborted)return;const e=u[r];if(e instanceof Qr)e.subscribeWith({onSubscribe(r){i.addEventListener("abort",()=>r.abort())},onSuccess(e){if(!i.aborted&&(s[r]=e,0===(l-=1))){let r;try{if(null==(r=b(s)))throw new Error("Single.zip: zipper function returned a null value.")}catch(r){return o(r),void c.abort()}n(r),c.abort()}},onError(r){o(r),c.abort()}});else{if(null==e){o(new Error("Single.zip: One of the sources is undefined.")),c.abort();break}s[r]=e,l-=1}}}var Gr=(r,e)=>{if(!c(r))return v(new Error("Single.zip: sources is not Iterable."));let n=e;o(e)||(n=qr);const t=new Qr(Br);return t.sources=r,t.zipper=n,t};const Hr=(r,e)=>[r,e];function Jr(e){const{onSuccess:n,onError:o,onSubscribe:t}=S(e);let s,c;const i=new r,{signal:u}=i;if(t(i),u.aborted)return;const{source:b,other:a,zipper:l}=this;b.subscribeWith({onSubscribe(r){u.addEventListener("abort",()=>r.abort())},onSuccess(r){if(!u.aborted&&(s=r,null!=c)){let r;try{if(null==(r=l(s,c)))throw new Error("Single.zipWith: zipper function returned a null value.")}catch(r){return o(r),void i.abort()}n(r),i.abort()}},onError(r){o(r),i.abort()}}),a.subscribeWith({onSubscribe(r){u.aborted?r.abort():u.addEventListener("abort",()=>r.abort())},onSuccess(r){if(!u.aborted&&(c=r,null!=s)){let r;try{if(null==(r=l(s,c)))throw new Error("Single.zipWith: zipper function returned a null value.")}catch(r){return o(r),void i.abort()}n(r),i.abort()}},onError(r){o(r),i.abort()}})}var Kr=(r,e,n)=>{if(!(e instanceof Qr))return r;let t=n;o(n)||(t=Hr);const s=new Qr(Jr);return s.source=r,s.other=e,s.zipper=t,s};class Qr{constructor(r){this.subscribeActual=r}static create(r){return z(r)}static amb(r){return g(r)}ambWith(r){return m(this,r)}cache(){return y(this)}compose(r){return O(this,r)}contains(r,e){return R(this,r,e)}static defer(r){return x(r)}delay(r,e,n){return T(this,r,e,n)}delaySubscription(r,e){return j(this,r,e)}delayUntil(r){return D(this,r)}doAfterSuccess(r){return N(this,r)}doAfterTerminate(r){return q(this,r)}doFinally(r){return G(this,r)}doOnAbort(r){return J(this,r)}doOnError(r){return Q(this,r)}doOnEvent(r){return X(this,r)}doOnSubscribe(r){return _(this,r)}doOnSuccess(r){return Z(this,r)}doOnTerminate(r){return er(this,r)}static error(r){return v(r)}flatMap(r){return or(this,r)}static fromCallable(r){return sr(r)}static fromPromise(r){return ir(r)}static fromResolvable(r){return br(r)}static just(r){return lr(r)}lift(r){return Sr(this,r)}map(r){return Er(this,r)}static merge(r){return wr(r)}static never(){return kr()}observeOn(r){return pr(this,r)}onErrorResumeNext(r){return Wr(this,r)}onErrorReturn(r){return Lr(this,r)}onErrorReturnItem(r){return Or(this,r)}retry(r){return Ir(this,r)}subscribeOn(r){return Ur(this,r)}subscribeWith(r){i(r)&&this.subscribeActual.call(this,r)}subscribe(e,n){const o=new r;let t=!1;return this.subscribeWith({onSubscribe(r){r.signal.addEventListener("abort",()=>{t||(t=!0,o.signal.aborted||o.abort())}),o.signal.addEventListener("abort",()=>{t||(t=!0,r.signal.aborted||r.abort())})},onSuccess:e,onError:n}),o}takeUntil(r){return Cr(this,r)}static timer(r,e){return Mr(r,e)}timeout(r,e){return Fr(this,r,e)}static zip(r,e){return Gr(r,e)}zipWith(r,e){return Kr(this,r,e)}toPromise(){return new Promise((r,e)=>{this.subscribe(r,e)})}then(r,e){return this.toPromise().then(r,e)}catch(r){return this.toPromise().catch(r)}}return Qr}(AbortController,Scheduler);