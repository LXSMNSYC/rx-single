var Single=function(r,e){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e;const n=(r,e)=>typeof r===e,c=r=>n(r,"function"),s=r=>n(r,"number"),o=r=>n(r,"object"),t=r=>null==r,i=r=>null!=r,u=(r,e)=>r instanceof e,l=r=>u(r,Array),a=r=>o(r)&&c(r.onSubscribe),b=r=>!t(r)&&(!!u(r,Promise)||(o(r)||c(r))&&c(r.then)),h=r=>r,S=r=>{throw r},f=r=>({onSubscribe:r.onSubscribe,onSuccess:c(r.onSuccess)?r.onSuccess:h,onError:c(r.onError)?r.onError:S}),E=(e,n)=>{const{onSubscribe:c,onSuccess:s}=f(e),o=new r.BooleanCancellable;c(o),o.cancelled||(s(n),o.cancel())},d=(e,n)=>{const{onSubscribe:c,onError:s}=f(e),o=new r.BooleanCancellable;c(o),o.cancelled||(s(n),o.cancel())},w=r=>u(r,e.interface)?r:e.current;function v(r){let e;try{if(e=this.supplier(),t(e))throw new Error("Single.error: Error supplier returned a null value.")}catch(r){e=r}d(r,e)}var m=r=>{let e=r;u(r,Error)||c(r)||(e=new Error("Single.error received a non-Error value.")),c(r)||(e=(r=>()=>r)(e));const n=new Qr(v);return n.supplier=e,n},p=r=>r instanceof Qr;function k(e){const{onSuccess:n,onError:c,onSubscribe:s}=f(e),o=new r.CompositeCancellable;s(o);const{sources:t}=this;for(const r of t){if(o.cancelled)return;if(!p(r)){c(new Error("Single.amb: One of the sources is a non-Single.")),o.cancel();break}r.subscribeWith({onSubscribe(r){o.add(r)},onSuccess(r){n(r),o.cancel()},onError(r){c(r),o.cancel()}})}}var g=r=>{if(!(r=>o(r)&&c(r[Symbol.iterator]))(r))return m(new Error("Single.amb: sources is not Iterable."));const e=new Qr(k);return e.sources=r,e};function y(e){const{onSuccess:n,onError:c,onSubscribe:s}=f(e),{sources:o}=this,{length:t}=o;if(0===t)d(e,new Error("Single.ambArray: sources Array is empty."));else{const e=new r.CompositeCancellable;s(e);for(let r=0;r<t;r+=1){const s=o[r];if(e.cancelled)return;if(!p(s)){c(new Error("Single.ambArray: One of the sources is a non-Single.")),e.cancel();break}s.subscribeWith({onSubscribe(r){e.add(r)},onSuccess(r){n(r),e.cancel()},onError(r){c(r),e.cancel()}})}}}var W=r=>{if(!l(r))return m(new Error("Single.ambArray: sources is not an Array."));const e=new Qr(y);return e.sources=r,e},C=(r,e)=>p(e)?W([r,e]):r;function A(e){const{onSuccess:n,onError:c,onSubscribe:s}=f(e),{source:o,cached:t,observers:u,subscribed:l}=this;if(t){const e=new r.BooleanCancellable;s(e);const{value:o,error:t}=this;i(o)&&n(o),i(t)&&c(t),e.cancel()}else{const n=u.length;u[n]=e;const c=new r.BooleanCancellable;c.addEventListener("cancel",()=>{u.splice(n,1)}),s(c),l||(o.subscribeWith({onSubscribe(){},onSuccess:r=>{this.cached=!0,this.value=r;for(const e of u)e.onSuccess(r);c.cancel(),this.observers=void 0},onError:r=>{this.cached=!0,this.error=r;for(const e of u)e.onError(r);c.cancel(),this.observers=void 0}}),this.subscribed=!0)}}var L=r=>{const e=new Qr(A);return e.source=r,e.cached=!1,e.subscribed=!1,e.observers=[],e};class O extends r.Cancellable{constructor(e,n){super(),this.success=e,this.error=n,this.link=new r.BooleanCancellable}get cancelled(){return this.link.cancelled}cancel(){return this.link.cancel()}setCancellable(e){if(u(e,r.Cancellable)){if(!this.cancelled){if(e.cancelled)return this.cancel(),!0;{const{link:r}=this;return this.link=e,r.cancel(),!0}}e.cancel()}return!1}onSuccess(r){if(!this.cancelled)try{t(r)?this.error(new Error("onSuccess called with a null value.")):this.success(r)}finally{this.cancel()}}onError(r){let e=r;if(u(r,Error)||(e=new Error("onError called with a non-Error value.")),!this.cancelled)try{this.error(e)}finally{this.cancel()}}}function z(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),s=new O(e,n);c(s);try{this.subscriber(s)}catch(r){s.onError(r)}}var P=r=>{if(!c(r))return m(new Error("Single.create: There are no subscribers."));const e=new Qr(z);return e.subscriber=r,e},R=(r,e)=>{if(!c(e))return r;let n;try{if(n=e(r),!p(n))throw new Error("Single.compose: transformer returned a non-Single.")}catch(r){n=m(r)}return n};const x=(r,e)=>r===e;function B(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),{value:s,comparer:o}=this;this.source.subscribeWith({onSubscribe:c,onSuccess(r){let c;try{c=o(r,s)}catch(r){return void n(r)}e(c)},onError:n})}var U=(r,e,n)=>{if(t(e))return r;let s=n;c(s)||(s=x);const o=new Qr(B);return o.source=r,o.value=e,o.comparer=s,o};function I(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r);let s,o;try{if(s=this.supplier(),!p(s))throw new Error("Single.defer: supplier returned a non-Single.")}catch(r){o=r}i(o)?d(r,o):s.subscribeWith({onSubscribe:c,onSuccess:e,onError:n})}var N=r=>{const e=new Qr(I);return e.supplier=r,e};function T(e){const{onSuccess:n,onError:c,onSubscribe:s}=f(e),{amount:o,scheduler:t,doDelayError:i}=this,u=new r.LinkedCancellable;s(u),this.source.subscribeWith({onSubscribe(r){u.link(r)},onSuccess(r){u.link(t.delay(()=>{n(r)},o))},onError(r){u.link(t.delay(()=>{c(r)},i?o:0))}})}var j=(r,e,n,c)=>{if(!s(e))return r;const o=new Qr(T);return o.source=r,o.amount=e,o.scheduler=w(n),o.doDelayError=c,o};function D(e){const{onSuccess:n,onError:c,onSubscribe:s}=f(e),{amount:o,scheduler:t,source:i}=this,u=new r.LinkedCancellable;s(u),u.link(t.delay(()=>{u.unlink(),i.subscribeWith({onSubscribe(r){u.link(r)},onSuccess:n,onError:c})},o))}var M=(r,e,n)=>{if(!s(e))return r;const c=new Qr(D);return c.source=r,c.amount=e,c.scheduler=w(n),c};function F(e){const{onSuccess:n,onError:c,onSubscribe:s}=f(e),{source:o,other:t}=this,i=new r.LinkedCancellable;s(i),t.subscribeWith({onSubscribe(r){i.link(r)},onSuccess(){i.unlink(),o.subscribeWith({onSubscribe(r){i.link(r)},onSuccess:n,onError:c})},onError:c})}var q=(r,e)=>{if(!p(e))return r;const n=new Qr(F);return n.source=r,n.other=e,n};function G(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),{source:s,callable:o}=this;s.subscribeWith({onSubscribe:c,onSuccess(r){e(r),o(r)},onError:n})}var H=(r,e)=>{if(!c(e))return r;const n=new Qr(G);return n.source=r,n.callable=e,n};function J(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),{source:s,callable:o}=this;s.subscribeWith({onSubscribe:c,onSuccess(r){e(r),o()},onError(r){n(r),o()}})}var K=(r,e)=>{if(!c(e))return r;const n=new Qr(J);return n.source=r,n.callable=e,n};function Q(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),{source:s,callable:o}=this;let t=!1;s.subscribeWith({onSubscribe(r){r.addEventListener("cancel",()=>{t||(o(),t=!0)}),c(r)},onSuccess(r){e(r),t||(o(),t=!0)},onError(r){n(r),t||(o(),t=!0)}})}var V=(r,e)=>{if(!c(e))return r;const n=new Qr(Q);return n.source=r,n.callable=e,n};function X(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),{source:s,callable:o}=this;s.subscribeWith({onSubscribe(r){r.addEventListener("cancel",o),c(r)},onSuccess:e,onError:n})}var Y=(r,e)=>{if(!c(e))return r;const n=new Qr(X);return n.source=r,n.callable=e,n};function Z(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),{source:s,callable:o}=this;s.subscribeWith({onSubscribe:c,onSuccess:e,onError(r){o(r),n(r)}})}var $=(r,e)=>{if(!c(e))return r;const n=new Qr(Z);return n.source=r,n.callable=e,n};function _(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),{source:s,callable:o}=this;s.subscribeWith({onSubscribe:c,onSuccess(r){o(r),e(r)},onError(r){o(void 0,r),n(r)}})}var rr=(r,e)=>{if(!c(e))return r;const n=new Qr(_);return n.source=r,n.callable=e,n};function er(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),{source:s,callable:o}=this;s.subscribeWith({onSubscribe:c,onSuccess(r){o(r),e(r)},onError:n})}var nr=(r,e)=>{if(!c(e))return r;const n=new Qr(er);return n.source=r,n.callable=e,n};function cr(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),{source:s,callable:o}=this;s.subscribeWith({onSubscribe(r){o(r),c(r)},onSuccess:e,onError:n})}var sr=(r,e)=>{if(!c(e))return r;const n=new Qr(cr);return n.source=r,n.callable=e,n};function or(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),{source:s,callable:o}=this;s.subscribeWith({onSubscribe:c,onSuccess(r){o(),e(r)},onError(r){o(),n(r)}})}var tr=(r,e)=>{if(!c(e))return r;const n=new Qr(or);return n.source=r,n.callable=e,n};function ir(e){const{onSubscribe:n,onError:c,onSuccess:s}=f(e),o=new r.LinkedCancellable;n(o);const{mapper:t,source:i}=this;i.subscribeWith({onSubscribe(r){o.link(r)},onSuccess(r){let e;o.unlink();try{if(e=t(r),!p(e))throw new Error("Single.flatMap: mapper returned a non-Single")}catch(r){return c(r),void o.cancel()}e.subscribeWith({onSubscribe(r){o.link(r)},onSuccess:s,onError:c})},onError:c})}var ur=(r,e)=>{if(!c(e))return r;const n=new Qr(ir);return n.source=r,n.mapper=e,n};function lr(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),s=new O(e,n);c(s),this.promise.then(r=>s.onSuccess(r),r=>s.onError(r))}var ar=r=>{if(!b(r))return m(new Error("Single.fromPromise: expects a Promise-like value."));const e=new Qr(lr);return e.promise=r,e};function br(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),s=new O(e,n);let o;c(s);try{o=this.callable()}catch(r){return void s.onError(r)}b(o)?ar(o).subscribeWith({onSubscribe(r){s.setCancellable(r)},onSuccess(r){s.onSuccess(r)},onError(r){s.onError(r)}}):s.onSuccess(o)}var hr=r=>{if(!c(r))return m(new Error("Single.fromCallable: callable received is not a function."));const e=new Qr(br);return e.callable=r,e};function Sr(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),s=new O(e,n);c(s),this.subscriber(r=>s.onSuccess(r),r=>s.onError(r))}var fr=r=>{if(!c(r))return m(new Error("Single.fromResolvable: expects a function."));const e=new Qr(Sr);return e.subscriber=r,e};function Er(r){E(r,this.value)}var dr=r=>{if(t(r))return m(new Error("Single.just: received a null value."));const e=new Qr(Er);return e.value=r,e};function wr(r){let e;try{if(e=this.operator(r),!a(e))throw new Error("Single.lift: operator returned a non-Observer.")}catch(e){return void d(r,e)}this.source.subscribeWith(e)}var vr=(r,e)=>{if(!c(e))return r;const n=new Qr(wr);return n.source=r,n.operator=e,n};function mr(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),{mapper:s}=this;this.source.subscribeWith({onSubscribe:c,onSuccess(r){let c;try{if(c=s(r),t(c))throw new Error("Single.map: mapper function returned a null value.")}catch(r){return void n(r)}e(c)},onError:n})}var pr=(r,e)=>{if(!c(e))return r;const n=new Qr(mr);return n.source=r,n.mapper=e,n};function kr(e){const{onSubscribe:n,onError:c,onSuccess:s}=f(e),o=new r.LinkedCancellable;n(o),this.source.subscribeWith({onSubscribe(r){o.link(r)},onSuccess(r){o.unlink();let e=r;p(r)||(e=m(new Error("Single.merge: source emitted a non-Single value."))),e.subscribeWith({onSubscribe(r){o.link(r)},onSuccess:s,onError:c})},onError:c})}var gr=r=>{if(!p(r))return m(new Error("Single.merge: source is not a Single."));const e=new Qr(kr);return e.source=r,e};function yr(e){const{onSubscribe:n,onSuccess:c,onError:s}=f(e),{source:o,scheduler:t}=this,i=new r.LinkedCancellable;n(i),o.subscribeWith({onSubscribe(r){i.link(r)},onSuccess(r){i.link(t.schedule(()=>{c(r)}))},onError(r){i.link(t.schedule(()=>{s(r)}))}})}var Wr=(r,e)=>{const n=new Qr(yr);return n.source=r,n.scheduler=w(e),n};function Cr(e){const{onSuccess:n,onError:s,onSubscribe:o}=f(e),{source:t,resumeIfError:i}=this,u=new r.LinkedCancellable;o(u),t.subscribeWith({onSubscribe(r){u.link(r)},onSuccess:n,onError(r){let e;if(u.unlink(),c(i))try{if(e=i(r),!p(e))throw new Error("Single.onErrorResumeNext: returned an non-Single.")}catch(e){return s(new Error([r,e])),void u.cancel()}else e=i;e.subscribeWith({onSubscribe(r){u.link(r)},onSuccess:n,onError:s})}})}var Ar=(r,e)=>{if(!c(e)&&!p(e))return r;const n=new Qr(Cr);return n.source=r,n.resumeIfError=e,n};function Lr(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),{source:s,item:o}=this;s.subscribeWith({onSubscribe:c,onSuccess:e,onError(r){let c;try{if(c=o(r),t(c))throw new Error(new Error("Single.onErrorReturn: returned a null value."))}catch(e){return void n([r,e])}e(c)}})}var Or=(r,e)=>{if(!c(e))return r;const n=new Qr(Lr);return n.source=r,n.item=e,n};function zr(r){const{onSuccess:e,onSubscribe:n}=f(r),{source:c,item:s}=this;c.subscribeWith({onSubscribe:n,onSuccess:e,onError(){e(s)}})}var Pr=(r,e)=>{if(t(e))return r;const n=new Qr(zr);return n.source=r,n.item=e,n};let Rr;var xr=()=>(t(Rr)&&(Rr=new Qr(e=>e.onSubscribe(r.UNCANCELLED))),Rr);function Br(e){const{onSubscribe:n,onSuccess:s,onError:o}=f(e),t=new r.LinkedCancellable;n(t);const{source:i,bipredicate:u}=this;let l=-1;const a=()=>{l+=1,t.unlink(),i.subscribeWith({onSubscribe(r){t.link(r)},onSuccess:s,onError(r){if(c(u)){u(l,r)?a():(o(r),t.cancel())}else a()}})};a()}var Ur=(r,e)=>{const n=new Qr(Br);return n.source=r,n.bipredicate=e,n};function Ir(e){const{onSubscribe:n,onSuccess:c,onError:s}=f(e),{source:o,scheduler:t}=this,i=new r.LinkedCancellable;n(i),i.link(t.schedule(()=>{i.unlink(),o.subscribeWith({onSubscribe(r){i.link(r)},onSuccess:c,onError:s})}))}var Nr=(r,e)=>{const n=new Qr(Ir);return n.source=r,n.scheduler=w(e),n};function Tr(e){const{onSubscribe:n,onSuccess:c,onError:s}=f(e),o=new r.CompositeCancellable;n(o);const{source:t,other:i}=this;i.subscribeWith({onSubscribe(r){o.add(r)},onSuccess(){s(new Error("Single.takeUntil: Source cancelled by other Single.")),o.cancel()},onError(r){s(new Error(["Single.takeUntil: Source cancelled by other Single.",r])),o.cancel()}}),t.subscribeWith({onSubscribe(r){o.add(r)},onSuccess(r){c(r),o.cancel()},onError(r){s(r),o.cancel()}})}const jr=(r,e)=>{if(!p(e))return r;const n=new Qr(Tr);return n.source=r,n.other=e,n};function Dr(r){const{onSuccess:e,onSubscribe:n}=f(r);n(this.scheduler.delay(()=>e(0),this.amount))}var Mr=(r,e)=>{if(!s(r))return m(new Error('Single.timer: "amount" is not a number.'));const n=new Qr(Dr);return n.amount=r,n.scheduler=w(e),n};function Fr(e){const{onSuccess:n,onError:c,onSubscribe:s}=f(e),{amount:o,scheduler:t}=this,i=new r.LinkedCancellable;s(i);const u=t.delay(()=>{c(new Error("Single.timeout: TimeoutException (no success signals within the specified timeout).")),i.cancel()},o);i.addEventListener("cancel",()=>u.cancel()),this.source.subscribeWith({onSubscribe(r){i.link(r)},onSuccess:n,onError:c})}var qr=(r,e,n)=>{if(!s(e))return r;const c=new Qr(Fr);return c.source=r,c.amount=e,c.scheduler=w(n),c};const Gr=r=>r;function Hr(e){const{onSuccess:n,onError:c,onSubscribe:s}=f(e),o=[],i=new r.CompositeCancellable;s(i);const{sources:u,zipper:l}=this,a=u.length;if(0===a)return c(new Error("Single.zipArray: source array is empty")),void i.cancel();let b=a;for(let r=0;r<a;r+=1){if(i.cancelled)return;const e=u[r];if(!p(e))return c(new Error("Single.zipArray: One of the sources is non-Single.")),void i.cancel();e.subscribeWith({onSubscribe(r){i.add(r)},onSuccess(e){if(o[r]=e,0===(b-=1)){let r;try{if(r=l(o),t(r))throw new Error("Single.zipArray: zipper function returned a null value.")}catch(r){return c(r),void i.cancel()}n(r),i.cancel()}},onError(r){c(r),i.cancel()}})}}var Jr=(r,e)=>{if(!l(r))return m(new Error("Single.zipArray: sources is a non-Array."));let n=e;c(e)||(n=Gr);const s=new Qr(Hr);return s.sources=r,s.zipper=n,s},Kr=(r,e,n)=>p(e)?Jr([r,e],n):r;class Qr{constructor(r){this.subscribeActual=r}static create(r){return P(r)}static amb(r){return g(r)}static ambArray(r){return W(r)}ambWith(r){return C(this,r)}cache(){return L(this)}compose(r){return R(this,r)}contains(r,e){return U(this,r,e)}static defer(r){return N(r)}delay(r,e,n){return j(this,r,e,n)}delaySubscription(r,e){return M(this,r,e)}delayUntil(r){return q(this,r)}doAfterSuccess(r){return H(this,r)}doAfterTerminate(r){return K(this,r)}doFinally(r){return V(this,r)}doOnCancel(r){return Y(this,r)}doOnError(r){return $(this,r)}doOnEvent(r){return rr(this,r)}doOnSubscribe(r){return sr(this,r)}doOnSuccess(r){return nr(this,r)}doOnTerminate(r){return tr(this,r)}static error(r){return m(r)}flatMap(r){return ur(this,r)}static fromCallable(r){return hr(r)}static fromPromise(r){return ar(r)}static fromResolvable(r){return fr(r)}static just(r){return dr(r)}lift(r){return vr(this,r)}map(r){return pr(this,r)}static merge(r){return gr(r)}static never(){return xr()}observeOn(r){return Wr(this,r)}onErrorResumeNext(r){return Ar(this,r)}onErrorReturn(r){return Or(this,r)}onErrorReturnItem(r){return Pr(this,r)}retry(r){return Ur(this,r)}subscribeOn(r){return Nr(this,r)}subscribeWith(r){a(r)&&this.subscribeActual.call(this,r)}subscribe(e,n){const c=new r.LinkedCancellable;return this.subscribeWith({onSubscribe(r){c.link(r)},onSuccess:e,onError:n}),c}takeUntil(r){return jr(this,r)}static timer(r,e){return Mr(r,e)}timeout(r,e){return qr(this,r,e)}static zipArray(r,e){return Jr(r,e)}zipWith(r,e){return Kr(this,r,e)}toPromise(){return new Promise((r,e)=>{this.subscribe(r,e)})}then(r,e){return this.toPromise().then(r,e)}catch(r){return this.toPromise().catch(r)}}return Qr}(Cancellable,Scheduler);