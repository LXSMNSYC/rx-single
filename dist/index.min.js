var Single=function(r,e){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e;const n=(r,e)=>typeof r===e,c=r=>n(r,"function"),s=r=>n(r,"number"),o=r=>n(r,"object"),t=r=>o(r)&&c(r[Symbol.iterator]),i=r=>o(r)&&c(r.onSubscribe),u=r=>null!=r&&(r instanceof Promise||(o(r)||c(r))&&c(r.then)),l=r=>r,a=r=>{throw r},b=r=>({onSubscribe:r.onSubscribe,onSuccess:c(r.onSuccess)?r.onSuccess:l,onError:c(r.onError)?r.onError:a}),h=(e,n)=>{const{onSubscribe:c,onSuccess:s}=b(e),o=new r.BooleanCancellable;c(o),o.cancelled||(s(n),o.cancel())},S=(e,n)=>{const{onSubscribe:c,onError:s}=b(e),o=new r.BooleanCancellable;c(o),o.cancelled||(s(n),o.cancel())};function f(r){let e;try{if(null==(e=this.supplier()))throw new Error("Single.error: Error supplier returned a null value.")}catch(r){e=r}S(r,e)}var E=r=>{let e=r;r instanceof Error||c(r)||(e=new Error("Single.error received a non-Error value.")),c(r)||(e=(r=>()=>r)(e));const n=new Gr(f);return n.supplier=e,n};function d(e){const{onSuccess:n,onError:c,onSubscribe:s}=b(e),o=new r.CompositeCancellable;s(o);const{sources:t}=this;for(const r of t){if(o.cancelled)return;if(!(r instanceof Gr)){c(new Error("Single.amb: One of the sources is a non-Single.")),o.cancel();break}r.subscribeWith({onSubscribe(r){o.add(r)},onSuccess(r){n(r),o.cancel()},onError(r){c(r),o.cancel()}})}}var w=r=>{if(!t(r))return E(new Error("Single.amb: sources is not Iterable."));const e=new Gr(d);return e.sources=r,e},v=(r,e)=>e instanceof Gr?w([r,e]):r;function m(e){const{onSuccess:n,onError:c,onSubscribe:s}=b(e),{source:o,cached:t,observers:i,subscribed:u}=this;if(t){const e=new r.BooleanCancellable;s(e);const{value:o,error:t}=this;null!=o&&n(o),null!=t&&c(t),e.cancel()}else{const n=i.length;i[n]=e;const c=new r.BooleanCancellable;c.addEventListener("cancel",()=>{i.splice(n,1)}),s(c),u||(o.subscribeWith({onSubscribe(){},onSuccess:r=>{this.cached=!0,this.value=r;for(const e of i)e.onSuccess(r);c.cancel(),this.observers=void 0},onError:r=>{this.cached=!0,this.error=r;for(const e of i)e.onError(r);c.cancel(),this.observers=void 0}}),this.subscribed=!0)}}var p=r=>{const e=new Gr(m);return e.source=r,e.cached=!1,e.subscribed=!1,e.observers=[],e};const g=new WeakMap;class k extends r.Cancellable{constructor(e,n){super(),this.success=e,this.error=n,g.set(this,new r.BooleanCancellable)}get cancelled(){return g.get(this).cancelled}cancel(){return g.get(this).cancel()}setCancellable(e){if(e instanceof r.Cancellable){if(!this.cancelled){if(e.cancelled)return this.cancel(),!0;{const r=g.get(this);return g.set(this,e),r.cancel(),!0}}e.cancel()}return!1}onSuccess(r){if(!this.cancelled)try{void 0===r?this.error(new Error("onSuccess called with a null value.")):this.success(r)}finally{this.cancel()}}onError(r){let e=r;if(r instanceof Error||(e=new Error("onError called with a non-Error value.")),!this.cancelled)try{this.error(e)}finally{this.cancel()}}}function W(r){const{onSuccess:e,onError:n,onSubscribe:c}=b(r),s=new k(e,n);c(s);try{this.subscriber(s)}catch(r){s.onError(r)}}var y=r=>{if("function"!=typeof r)return E(new Error("Single.create: There are no subscribers."));const e=new Gr(W);return e.subscriber=r,e},C=(r,e)=>{if(!c(e))return r;let n;try{if(!((n=e(r))instanceof Gr))throw new Error("Single.compose: transformer returned a non-Single.")}catch(r){n=E(r)}return n};const L=(r,e)=>r===e;function O(r){const{onSuccess:e,onError:n,onSubscribe:c}=b(r),{value:s,comparer:o}=this;this.source.subscribeWith({onSubscribe:c,onSuccess(r){let c;try{c=o(r,s)}catch(r){return void n(r)}e(c)},onError:n})}var z=(r,e,n)=>{if(null==e)return r;let s=n;c(s)||(s=L);const o=new Gr(O);return o.source=r,o.value=e,o.comparer=s,o};function P(r){const{onSuccess:e,onError:n,onSubscribe:c}=b(r);let s,o;try{if(!((s=this.supplier())instanceof Gr))throw new Error("Single.defer: supplier returned a non-Single.")}catch(r){o=r}null!=o?S(r,o):s.subscribeWith({onSubscribe:c,onSuccess:e,onError:n})}var R=r=>{const e=new Gr(P);return e.supplier=r,e};function x(e){const{onSuccess:n,onError:c,onSubscribe:s}=b(e),{amount:o,scheduler:t,doDelayError:i}=this,u=new r.LinkedCancellable;s(u),this.source.subscribeWith({onSubscribe(r){u.link(r)},onSuccess(r){u.link(t.delay(()=>{n(r)},o))},onError(r){u.link(t.delay(()=>{c(r)},i?o:0))}})}var A=(r,n,c,o)=>{if(!s(n))return r;let t=c;t instanceof e.interface||(t=e.current);const i=new Gr(x);return i.source=r,i.amount=n,i.scheduler=t,i.doDelayError=o,i};function B(e){const{onSuccess:n,onError:c,onSubscribe:s}=b(e),{amount:o,scheduler:t,source:i}=this,u=new r.LinkedCancellable;s(u),u.link(t.delay(()=>{u.unlink(),i.subscribeWith({onSubscribe(r){u.link(r)},onSuccess:n,onError:c})},o))}var I=(r,n,c)=>{if(!s(n))return r;let o=c;o instanceof e.interface||(o=e.current);const t=new Gr(B);return t.source=r,t.amount=n,t.scheduler=o,t};function U(e){const{onSuccess:n,onError:c,onSubscribe:s}=b(e),{source:o,other:t}=this,i=new r.LinkedCancellable;s(i),t.subscribeWith({onSubscribe(r){i.link(r)},onSuccess(){i.unlink(),o.subscribeWith({onSubscribe(r){i.link(r)},onSuccess:n,onError:c})},onError:c})}var N=(r,e)=>{if(!(e instanceof Gr))return r;const n=new Gr(U);return n.source=r,n.other=e,n};function T(r){const{onSuccess:e,onError:n,onSubscribe:c}=b(r),{source:s,callable:o}=this;s.subscribeWith({onSubscribe:c,onSuccess(r){e(r),o(r)},onError:n})}var j=(r,e)=>{if(!c(e))return r;const n=new Gr(T);return n.source=r,n.callable=e,n};function D(r){const{onSuccess:e,onError:n,onSubscribe:c}=b(r),{source:s,callable:o}=this;s.subscribeWith({onSubscribe:c,onSuccess(r){e(r),o()},onError(r){n(r),o()}})}var M=(r,e)=>{if(!c(e))return r;const n=new Gr(D);return n.source=r,n.callable=e,n};function F(r){const{onSuccess:e,onError:n,onSubscribe:c}=b(r),{source:s,callable:o}=this;let t=!1;s.subscribeWith({onSubscribe(r){r.addEventListener("cancel",()=>{t||(o(),t=!0)}),c(r)},onSuccess(r){e(r),t||(o(),t=!0)},onError(r){n(r),t||(o(),t=!0)}})}var q=(r,e)=>{if(!c(e))return r;const n=new Gr(F);return n.source=r,n.callable=e,n};function G(r){const{onSuccess:e,onError:n,onSubscribe:c}=b(r),{source:s,callable:o}=this;s.subscribeWith({onSubscribe(r){r.addEventListener("cancel",o),c(r)},onSuccess:e,onError:n})}var H=(r,e)=>{if(!c(e))return r;const n=new Gr(G);return n.source=r,n.callable=e,n};function J(r){const{onSuccess:e,onError:n,onSubscribe:c}=b(r),{source:s,callable:o}=this;s.subscribeWith({onSubscribe:c,onSuccess:e,onError(r){o(r),n(r)}})}var K=(r,e)=>{if(!c(e))return r;const n=new Gr(J);return n.source=r,n.callable=e,n};function Q(r){const{onSuccess:e,onError:n,onSubscribe:c}=b(r),{source:s,callable:o}=this;s.subscribeWith({onSubscribe:c,onSuccess(r){o(r),e(r)},onError(r){o(void 0,r),n(r)}})}var V=(r,e)=>{if(!c(e))return r;const n=new Gr(Q);return n.source=r,n.callable=e,n};function X(r){const{onSuccess:e,onError:n,onSubscribe:c}=b(r),{source:s,callable:o}=this;s.subscribeWith({onSubscribe:c,onSuccess(r){o(r),e(r)},onError:n})}var Y=(r,e)=>{if(!c(e))return r;const n=new Gr(X);return n.source=r,n.callable=e,n};function Z(r){const{onSuccess:e,onError:n,onSubscribe:c}=b(r),{source:s,callable:o}=this;s.subscribeWith({onSubscribe(r){o(r),c(r)},onSuccess:e,onError:n})}var $=(r,e)=>{if(!c(e))return r;const n=new Gr(Z);return n.source=r,n.callable=e,n};function _(r){const{onSuccess:e,onError:n,onSubscribe:c}=b(r),{source:s,callable:o}=this;s.subscribeWith({onSubscribe:c,onSuccess(r){o(),e(r)},onError(r){o(),n(r)}})}var rr=(r,e)=>{if(!c(e))return r;const n=new Gr(_);return n.source=r,n.callable=e,n};function er(e){const{onSubscribe:n,onError:c,onSuccess:s}=b(e),o=new r.LinkedCancellable;n(o);const{mapper:t,source:i}=this;i.subscribeWith({onSubscribe(r){o.link(r)},onSuccess(r){let e;o.unlink();try{if(!((e=t(r))instanceof Gr))throw new Error("Single.flatMap: mapper returned a non-Single")}catch(r){return c(r),void o.cancel()}e.subscribeWith({onSubscribe(r){o.link(r)},onSuccess:s,onError:c})},onError:c})}var nr=(r,e)=>{if(!c(e))return r;const n=new Gr(er);return n.source=r,n.mapper=e,n};function cr(r){const{onSuccess:e,onError:n,onSubscribe:c}=b(r),s=new k(e,n);c(s),this.promise.then(r=>s.onSuccess(r),r=>s.onError(r))}var sr=r=>{if(!u(r))return E(new Error("Single.fromPromise: expects a Promise-like value."));const e=new Gr(cr);return e.promise=r,e};function or(r){const{onSuccess:e,onError:n,onSubscribe:c}=b(r),s=new k(e,n);let o;c(s);try{o=this.callable()}catch(r){return void s.onError(r)}u(o)?sr(o).subscribeWith({onSubscribe(r){s.setCancellable(r)},onSuccess(r){s.onSuccess(r)},onError(r){s.onError(r)}}):s.onSuccess(o)}var tr=r=>{if(!c(r))return E(new Error("Single.fromCallable: callable received is not a function."));const e=new Gr(or);return e.callable=r,e};function ir(r){const{onSuccess:e,onError:n,onSubscribe:c}=b(r),s=new k(e,n);c(s),this.subscriber(r=>s.onSuccess(r),r=>s.onError(r))}var ur=r=>{if(!c(r))return E(new Error("Single.fromResolvable: expects a function."));const e=new Gr(ir);return e.subscriber=r,e};function lr(r){h(r,this.value)}var ar=r=>{if(null==r)return E(new Error("Single.just: received a null value."));const e=new Gr(lr);return e.value=r,e};function br(r){let e;try{if(e=this.operator(r),!i(e))throw new Error("Single.lift: operator returned a non-Observer.")}catch(e){return void S(r,e)}this.source.subscribeWith(e)}var hr=(r,e)=>{if(!c(e))return r;const n=new Gr(br);return n.source=r,n.operator=e,n};const Sr=r=>r;function fr(r){const{onSuccess:e,onError:n,onSubscribe:c}=b(r),{mapper:s}=this;this.source.subscribeWith({onSubscribe:c,onSuccess(r){let c;try{if(null==(c=s(r)))throw new Error("Single.map: mapper function returned a null value.")}catch(r){return void n(r)}e(c)},onError:n})}var Er=(r,e)=>{let n=e;c(e)||(n=Sr);const s=new Gr(fr);return s.source=r,s.mapper=n,s};function dr(e){const{onSubscribe:n,onError:c,onSuccess:s}=b(e),o=new r.LinkedCancellable;n(o),this.source.subscribeWith({onSubscribe(r){o.link(r)},onSuccess(r){o.unlink();let e=r;r instanceof Gr||(e=E(new Error("Single.merge: source emitted a non-Single value."))),e.subscribeWith({onSubscribe(r){o.link(r)},onSuccess:s,onError:c})},onError:c})}var wr=r=>{if(!(r instanceof Gr))return E(new Error("Single.merge: source is not a Single."));const e=new Gr(dr);return e.source=r,e};function vr(e){const{onSubscribe:n,onSuccess:c,onError:s}=b(e),{source:o,scheduler:t}=this,i=new r.LinkedCancellable;n(i),o.subscribeWith({onSubscribe(r){i.link(r)},onSuccess(r){i.link(t.schedule(()=>{c(r)}))},onError(r){i.link(t.schedule(()=>{s(r)}))}})}var mr=(r,n)=>{let c=n;c instanceof e.interface||(c=e.current);const s=new Gr(vr);return s.source=r,s.scheduler=c,s};function pr(e){const{onSuccess:n,onError:s,onSubscribe:o}=b(e),{source:t,resumeIfError:i}=this,u=new r.LinkedCancellable;o(u),t.subscribeWith({onSubscribe(r){u.link(r)},onSuccess:n,onError(r){let e;if(u.unlink(),c(i))try{if(!((e=i(r))instanceof Gr))throw new Error("Single.onErrorResumeNext: returned an non-Single.")}catch(e){return s(new Error([r,e])),void u.cancel()}else e=i;e.subscribeWith({onSubscribe(r){u.link(r)},onSuccess:n,onError:s})}})}var gr=(r,e)=>{if(!(c(e)||e instanceof Gr))return r;const n=new Gr(pr);return n.source=r,n.resumeIfError=e,n};function kr(r){const{onSuccess:e,onError:n,onSubscribe:c}=b(r),{source:s,item:o}=this;s.subscribeWith({onSubscribe:c,onSuccess:e,onError(r){let c;try{if(null==(c=o(r)))throw new Error(new Error("Single.onErrorReturn: returned a null value."))}catch(e){return void n([r,e])}e(c)}})}var Wr=(r,e)=>{if(!c(e))return r;const n=new Gr(kr);return n.source=r,n.item=e,n};function yr(r){const{onSuccess:e,onSubscribe:n}=b(r),{source:c,item:s}=this;c.subscribeWith({onSubscribe:n,onSuccess:e,onError(){e(s)}})}var Cr=(r,e)=>{if(null==e)return r;const n=new Gr(yr);return n.source=r,n.item=e,n};function Lr(e){e.onSubscribe(r.UNCANCELLED)}let Or;var zr=()=>(void 0===Or&&(Or=new Gr(Lr)),Or);function Pr(e){const{onSubscribe:n,onSuccess:s,onError:o}=b(e),t=new r.LinkedCancellable;n(t);const{source:i,bipredicate:u}=this;let l=0;const a=()=>{l+=1,t.unlink(),i.subscribeWith({onSubscribe(r){t.link(r)},onSuccess:s,onError(r){if(c(u)){u(l,r)?a():(o(r),t.cancel())}else a()}})};a()}var Rr=(r,e)=>{const n=new Gr(Pr);return n.source=r,n.bipredicate=e,n};function xr(e){const{onSubscribe:n,onSuccess:c,onError:s}=b(e),{source:o,scheduler:t}=this,i=new r.LinkedCancellable;n(i),i.link(t.schedule(()=>{i.unlink(),o.subscribeWith({onSubscribe(r){i.link(r)},onSuccess:c,onError:s})}))}var Ar=(r,n)=>{let c=n;c instanceof e.interface||(c=e.current);const s=new Gr(xr);return s.source=r,s.scheduler=c,s};function Br(e){const{onSubscribe:n,onSuccess:c,onError:s}=b(e),o=new r.CompositeCancellable;n(o);const{source:t,other:i}=this;i.subscribeWith({onSubscribe(r){o.add(r)},onSuccess(){s(new Error("Single.takeUntil: Source cancelled by other Single.")),o.cancel()},onError(r){s(new Error(["Single.takeUntil: Source cancelled by other Single.",r])),o.cancel()}}),t.subscribeWith({onSubscribe(r){o.add(r)},onSuccess(r){c(r),o.cancel()},onError(r){s(r),o.cancel()}})}const Ir=(r,e)=>{if(!(e instanceof Gr))return r;const n=new Gr(Br);return n.source=r,n.other=e,n};function Ur(r){const{onSuccess:e,onSubscribe:n}=b(r);n(this.scheduler.delay(()=>e(0),this.amount))}var Nr=(r,n)=>{if(!s(r))return E(new Error('Single.timer: "amount" is not a number.'));let c=n;c instanceof e.interface||(c=e.current);const o=new Gr(Ur);return o.amount=r,o.scheduler=c,o};function Tr(e){const{onSuccess:n,onError:c,onSubscribe:s}=b(e),{amount:o,scheduler:t}=this,i=new r.LinkedCancellable;s(i);const u=t.delay(()=>{c(new Error("Single.timeout: TimeoutException (no success signals within the specified timeout).")),i.cancel()},o);i.addEventListener("cancel",()=>u.cancel()),this.source.subscribeWith({onSubscribe(r){i.link(r)},onSuccess:n,onError:c})}var jr=(r,n,c)=>{if(!s(n))return r;let o=c;o instanceof e.interface||(o=e.current);const t=new Gr(Tr);return t.source=r,t.amount=n,t.scheduler=o,t};const Dr=r=>r;function Mr(e){const{onSuccess:n,onError:c,onSubscribe:s}=b(e),o=[],t=new r.CompositeCancellable;s(t);const{sources:i,zipper:u}=this,l=i.length;if(0===l)return c(new Error("Single.zip: empty iterable")),void t.cancel();let a=l;for(let r=0;r<l;r+=1){if(t.cancelled)return;const e=i[r];if(e instanceof Gr)e.subscribeWith({onSubscribe(r){t.add(r)},onSuccess(e){if(o[r]=e,0===(a-=1)){let r;try{if(null==(r=u(o)))throw new Error("Single.zip: zipper function returned a null value.")}catch(r){return c(r),void t.cancel()}n(r),t.cancel()}},onError(r){c(r),t.cancel()}});else{if(null==e){c(new Error("Single.zip: One of the sources is undefined.")),t.cancel();break}o[r]=e,a-=1}}}var Fr=(r,e)=>{if(!t(r))return E(new Error("Single.zip: sources is not Iterable."));let n=e;c(e)||(n=Dr);const s=new Gr(Mr);return s.sources=r,s.zipper=n,s},qr=(r,e,n)=>e instanceof Gr?Fr([r,e],n):r;class Gr{constructor(r){this.subscribeActual=r}static create(r){return y(r)}static amb(r){return w(r)}ambWith(r){return v(this,r)}cache(){return p(this)}compose(r){return C(this,r)}contains(r,e){return z(this,r,e)}static defer(r){return R(r)}delay(r,e,n){return A(this,r,e,n)}delaySubscription(r,e){return I(this,r,e)}delayUntil(r){return N(this,r)}doAfterSuccess(r){return j(this,r)}doAfterTerminate(r){return M(this,r)}doFinally(r){return q(this,r)}doOnCancel(r){return H(this,r)}doOnError(r){return K(this,r)}doOnEvent(r){return V(this,r)}doOnSubscribe(r){return $(this,r)}doOnSuccess(r){return Y(this,r)}doOnTerminate(r){return rr(this,r)}static error(r){return E(r)}flatMap(r){return nr(this,r)}static fromCallable(r){return tr(r)}static fromPromise(r){return sr(r)}static fromResolvable(r){return ur(r)}static just(r){return ar(r)}lift(r){return hr(this,r)}map(r){return Er(this,r)}static merge(r){return wr(r)}static never(){return zr()}observeOn(r){return mr(this,r)}onErrorResumeNext(r){return gr(this,r)}onErrorReturn(r){return Wr(this,r)}onErrorReturnItem(r){return Cr(this,r)}retry(r){return Rr(this,r)}subscribeOn(r){return Ar(this,r)}subscribeWith(r){i(r)&&this.subscribeActual.call(this,r)}subscribe(e,n){const c=new r.LinkedCancellable;return this.subscribeWith({onSubscribe(r){c.link(r)},onSuccess:e,onError:n}),c}takeUntil(r){return Ir(this,r)}static timer(r,e){return Nr(r,e)}timeout(r,e){return jr(this,r,e)}static zip(r,e){return Fr(r,e)}zipWith(r,e){return qr(this,r,e)}toPromise(){return new Promise((r,e)=>{this.subscribe(r,e)})}then(r,e){return this.toPromise().then(r,e)}catch(r){return this.toPromise().catch(r)}}return Gr}(Cancellable,Scheduler);