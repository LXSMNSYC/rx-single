var Single=function(r,e){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e;const n=(r,e)=>typeof r===e,s=r=>n(r,"function"),c=r=>n(r,"number"),o=r=>n(r,"object"),t=r=>null==r,i=r=>null!=r,u=(r,e)=>r instanceof e,l=r=>u(r,Array),a=r=>o(r)&&s(r[Symbol.iterator]),b=r=>o(r)&&s(r.onSubscribe),h=r=>!t(r)&&(!!u(r,Promise)||(o(r)||s(r))&&s(r.then)),S=r=>r,f=r=>{throw r},E=r=>({onSubscribe:r.onSubscribe,onSuccess:s(r.onSuccess)?r.onSuccess:S,onError:s(r.onError)?r.onError:f}),d=(e,n)=>{const{onSubscribe:s,onSuccess:c}=E(e),o=new r.BooleanCancellable;s(o),o.cancelled||(c(n),o.cancel())},w=(e,n)=>{const{onSubscribe:s,onError:c}=E(e),o=new r.BooleanCancellable;s(o),o.cancelled||(c(n),o.cancel())},v=r=>u(r,e.interface)?r:e.current;function m(r){let e;try{if(e=this.supplier(),t(e))throw new Error("Single.error: Error supplier returned a null value.")}catch(r){e=r}w(r,e)}var p=r=>{let e=r;u(r,Error)||s(r)||(e=new Error("Single.error received a non-Error value.")),s(r)||(e=(r=>()=>r)(e));const n=new Xr(m);return n.supplier=e,n},g=r=>r instanceof Xr;function k(e){const{onSuccess:n,onError:s,onSubscribe:c}=E(e),o=new r.CompositeCancellable;c(o);const{sources:t}=this;for(const r of t){if(o.cancelled)return;if(!g(r)){s(new Error("Single.amb: One of the sources is a non-Single.")),o.cancel();break}r.subscribeWith({onSubscribe(r){o.add(r)},onSuccess(r){n(r),o.cancel()},onError(r){s(r),o.cancel()}})}}var y=r=>{if(!a(r))return p(new Error("Single.amb: sources is not Iterable."));const e=new Xr(k);return e.sources=r,e};function W(e){const{onSuccess:n,onError:s,onSubscribe:c}=E(e),{sources:o}=this,{length:t}=o;if(0===t)w(e,new Error("Single.ambArray: sources Array is empty."));else{const e=new r.CompositeCancellable;c(e);for(let r=0;r<t;r+=1){const c=o[r];if(e.cancelled)return;if(!g(c)){s(new Error("Single.ambArray: One of the sources is a non-Single.")),e.cancel();break}c.subscribeWith({onSubscribe(r){e.add(r)},onSuccess(r){n(r),e.cancel()},onError(r){s(r),e.cancel()}})}}}var C=r=>{if(!l(r))return p(new Error("Single.ambArray: sources is not an Array."));const e=new Xr(W);return e.sources=r,e},A=(r,e)=>g(e)?C([r,e]):r;function L(e){const{onSuccess:n,onError:s,onSubscribe:c}=E(e),{source:o,cached:t,observers:u,subscribed:l}=this;if(t){const e=new r.BooleanCancellable;c(e);const{value:o,error:t}=this;i(o)&&n(o),i(t)&&s(t),e.cancel()}else{const n=u.length;u[n]=e;const s=new r.BooleanCancellable;s.addEventListener("cancel",()=>{u.splice(n,1)}),c(s),l||(o.subscribeWith({onSubscribe(){},onSuccess:r=>{this.cached=!0,this.value=r;for(const e of u)e.onSuccess(r);s.cancel(),this.observers=void 0},onError:r=>{this.cached=!0,this.error=r;for(const e of u)e.onError(r);s.cancel(),this.observers=void 0}}),this.subscribed=!0)}}var O=r=>{const e=new Xr(L);return e.source=r,e.cached=!1,e.subscribed=!1,e.observers=[],e};class z extends r.Cancellable{constructor(e,n){super(),this.success=e,this.error=n,this.link=new r.BooleanCancellable}get cancelled(){return this.link.cancelled}cancel(){return this.link.cancel()}setCancellable(e){if(u(e,r.Cancellable)){if(!this.cancelled){if(e.cancelled)return this.cancel(),!0;{const{link:r}=this;return this.link=e,r.cancel(),!0}}e.cancel()}return!1}onSuccess(r){if(!this.cancelled)try{t(r)?this.error(new Error("onSuccess called with a null value.")):this.success(r)}finally{this.cancel()}}onError(r){let e=r;if(u(r,Error)||(e=new Error("onError called with a non-Error value.")),!this.cancelled)try{this.error(e)}finally{this.cancel()}}}function P(r){const{onSuccess:e,onError:n,onSubscribe:s}=E(r),c=new z(e,n);s(c);try{this.subscriber(c)}catch(r){c.onError(r)}}var R=r=>{if(!s(r))return p(new Error("Single.create: There are no subscribers."));const e=new Xr(P);return e.subscriber=r,e},x=(r,e)=>{if(!s(e))return r;let n;try{if(n=e(r),!g(n))throw new Error("Single.compose: transformer returned a non-Single.")}catch(r){n=p(r)}return n};const B=(r,e)=>r===e;function I(r){const{onSuccess:e,onError:n,onSubscribe:s}=E(r),{value:c,comparer:o}=this;this.source.subscribeWith({onSubscribe:s,onSuccess(r){let s;try{s=o(r,c)}catch(r){return void n(r)}e(s)},onError:n})}var U=(r,e,n)=>{if(t(e))return r;let c=n;s(c)||(c=B);const o=new Xr(I);return o.source=r,o.value=e,o.comparer=c,o};function N(r){const{onSuccess:e,onError:n,onSubscribe:s}=E(r);let c,o;try{if(c=this.supplier(),!g(c))throw new Error("Single.defer: supplier returned a non-Single.")}catch(r){o=r}i(o)?w(r,o):c.subscribeWith({onSubscribe:s,onSuccess:e,onError:n})}var T=r=>{const e=new Xr(N);return e.supplier=r,e};function j(e){const{onSuccess:n,onError:s,onSubscribe:c}=E(e),{amount:o,scheduler:t,doDelayError:i}=this,u=new r.LinkedCancellable;c(u),this.source.subscribeWith({onSubscribe(r){u.link(r)},onSuccess(r){u.link(t.delay(()=>{n(r)},o))},onError(r){u.link(t.delay(()=>{s(r)},i?o:0))}})}var D=(r,e,n,s)=>{if(!c(e))return r;const o=new Xr(j);return o.source=r,o.amount=e,o.scheduler=v(n),o.doDelayError=s,o};function M(e){const{onSuccess:n,onError:s,onSubscribe:c}=E(e),{amount:o,scheduler:t,source:i}=this,u=new r.LinkedCancellable;c(u),u.link(t.delay(()=>{u.unlink(),i.subscribeWith({onSubscribe(r){u.link(r)},onSuccess:n,onError:s})},o))}var F=(r,e,n)=>{if(!c(e))return r;const s=new Xr(M);return s.source=r,s.amount=e,s.scheduler=v(n),s};function q(e){const{onSuccess:n,onError:s,onSubscribe:c}=E(e),{source:o,other:t}=this,i=new r.LinkedCancellable;c(i),t.subscribeWith({onSubscribe(r){i.link(r)},onSuccess(){i.unlink(),o.subscribeWith({onSubscribe(r){i.link(r)},onSuccess:n,onError:s})},onError:s})}var G=(r,e)=>{if(!g(e))return r;const n=new Xr(q);return n.source=r,n.other=e,n};function H(r){const{onSuccess:e,onError:n,onSubscribe:s}=E(r),{source:c,callable:o}=this;c.subscribeWith({onSubscribe:s,onSuccess(r){e(r),o(r)},onError:n})}var J=(r,e)=>{if(!s(e))return r;const n=new Xr(H);return n.source=r,n.callable=e,n};function K(r){const{onSuccess:e,onError:n,onSubscribe:s}=E(r),{source:c,callable:o}=this;c.subscribeWith({onSubscribe:s,onSuccess(r){e(r),o()},onError(r){n(r),o()}})}var Q=(r,e)=>{if(!s(e))return r;const n=new Xr(K);return n.source=r,n.callable=e,n};function V(r){const{onSuccess:e,onError:n,onSubscribe:s}=E(r),{source:c,callable:o}=this;let t=!1;c.subscribeWith({onSubscribe(r){r.addEventListener("cancel",()=>{t||(o(),t=!0)}),s(r)},onSuccess(r){e(r),t||(o(),t=!0)},onError(r){n(r),t||(o(),t=!0)}})}var X=(r,e)=>{if(!s(e))return r;const n=new Xr(V);return n.source=r,n.callable=e,n};function Y(r){const{onSuccess:e,onError:n,onSubscribe:s}=E(r),{source:c,callable:o}=this;c.subscribeWith({onSubscribe(r){r.addEventListener("cancel",o),s(r)},onSuccess:e,onError:n})}var Z=(r,e)=>{if(!s(e))return r;const n=new Xr(Y);return n.source=r,n.callable=e,n};function $(r){const{onSuccess:e,onError:n,onSubscribe:s}=E(r),{source:c,callable:o}=this;c.subscribeWith({onSubscribe:s,onSuccess:e,onError(r){o(r),n(r)}})}var _=(r,e)=>{if(!s(e))return r;const n=new Xr($);return n.source=r,n.callable=e,n};function rr(r){const{onSuccess:e,onError:n,onSubscribe:s}=E(r),{source:c,callable:o}=this;c.subscribeWith({onSubscribe:s,onSuccess(r){o(r),e(r)},onError(r){o(void 0,r),n(r)}})}var er=(r,e)=>{if(!s(e))return r;const n=new Xr(rr);return n.source=r,n.callable=e,n};function nr(r){const{onSuccess:e,onError:n,onSubscribe:s}=E(r),{source:c,callable:o}=this;c.subscribeWith({onSubscribe:s,onSuccess(r){o(r),e(r)},onError:n})}var sr=(r,e)=>{if(!s(e))return r;const n=new Xr(nr);return n.source=r,n.callable=e,n};function cr(r){const{onSuccess:e,onError:n,onSubscribe:s}=E(r),{source:c,callable:o}=this;c.subscribeWith({onSubscribe(r){o(r),s(r)},onSuccess:e,onError:n})}var or=(r,e)=>{if(!s(e))return r;const n=new Xr(cr);return n.source=r,n.callable=e,n};function tr(r){const{onSuccess:e,onError:n,onSubscribe:s}=E(r),{source:c,callable:o}=this;c.subscribeWith({onSubscribe:s,onSuccess(r){o(),e(r)},onError(r){o(),n(r)}})}var ir=(r,e)=>{if(!s(e))return r;const n=new Xr(tr);return n.source=r,n.callable=e,n};function ur(e){const{onSubscribe:n,onError:s,onSuccess:c}=E(e),o=new r.LinkedCancellable;n(o);const{mapper:t,source:i}=this;i.subscribeWith({onSubscribe(r){o.link(r)},onSuccess(r){let e;try{if(e=t(r),!g(e))throw new Error("Single.flatMap: mapper returned a non-Single")}catch(r){return void s(r)}o.unlink(),e.subscribeWith({onSubscribe(r){o.link(r)},onSuccess:c,onError:s})},onError:s})}var lr=(r,e)=>{if(!s(e))return r;const n=new Xr(ur);return n.source=r,n.mapper=e,n};function ar(r){const{onSuccess:e,onError:n,onSubscribe:s}=E(r),c=new z(e,n);s(c),this.promise.then(r=>c.onSuccess(r),r=>c.onError(r))}var br=r=>{if(!h(r))return p(new Error("Single.fromPromise: expects a Promise-like value."));const e=new Xr(ar);return e.promise=r,e};function hr(r){const{onSuccess:e,onError:n,onSubscribe:s}=E(r),c=new z(e,n);let o;s(c);try{o=this.callable()}catch(r){return void c.onError(r)}h(o)?br(o).subscribeWith({onSubscribe(r){c.setCancellable(r)},onSuccess(r){c.onSuccess(r)},onError(r){c.onError(r)}}):c.onSuccess(o)}var Sr=r=>{if(!s(r))return p(new Error("Single.fromCallable: callable received is not a function."));const e=new Xr(hr);return e.callable=r,e};function fr(r){const{onSuccess:e,onError:n,onSubscribe:s}=E(r),c=new z(e,n);s(c),this.subscriber(r=>c.onSuccess(r),r=>c.onError(r))}var Er=r=>{if(!s(r))return p(new Error("Single.fromResolvable: expects a function."));const e=new Xr(fr);return e.subscriber=r,e};function dr(r){d(r,this.value)}var wr=r=>{if(t(r))return p(new Error("Single.just: received a null value."));const e=new Xr(dr);return e.value=r,e};function vr(r){let e;try{if(e=this.operator(r),!b(e))throw new Error("Single.lift: operator returned a non-Observer.")}catch(e){return void w(r,e)}this.source.subscribeWith(e)}var mr=(r,e)=>{if(!s(e))return r;const n=new Xr(vr);return n.source=r,n.operator=e,n};function pr(r){const{onSuccess:e,onError:n,onSubscribe:s}=E(r),{mapper:c}=this;this.source.subscribeWith({onSubscribe:s,onSuccess(r){let s;try{if(s=c(r),t(s))throw new Error("Single.map: mapper function returned a null value.")}catch(r){return void n(r)}e(s)},onError:n})}var gr=(r,e)=>{if(!s(e))return r;const n=new Xr(pr);return n.source=r,n.mapper=e,n};function kr(e){const{onSubscribe:n,onError:s,onSuccess:c}=E(e),o=new r.LinkedCancellable;n(o),this.source.subscribeWith({onSubscribe(r){o.link(r)},onSuccess(r){o.unlink();let e=r;g(r)||(e=p(new Error("Single.merge: source emitted a non-Single value."))),e.subscribeWith({onSubscribe(r){o.link(r)},onSuccess:c,onError:s})},onError:s})}var yr=r=>{if(!g(r))return p(new Error("Single.merge: source is not a Single."));const e=new Xr(kr);return e.source=r,e};function Wr(e){const{onSubscribe:n,onSuccess:s,onError:c}=E(e),{source:o,scheduler:t}=this,i=new r.LinkedCancellable;n(i),o.subscribeWith({onSubscribe(r){i.link(r)},onSuccess(r){i.link(t.schedule(()=>{s(r)}))},onError(r){i.link(t.schedule(()=>{c(r)}))}})}var Cr=(r,e)=>{const n=new Xr(Wr);return n.source=r,n.scheduler=v(e),n};function Ar(e){const{onSuccess:n,onError:c,onSubscribe:o}=E(e),{source:t,resumeIfError:i}=this,u=new r.LinkedCancellable;o(u),t.subscribeWith({onSubscribe(r){u.link(r)},onSuccess:n,onError(r){let e;if(s(i))try{if(e=i(r),!g(e))throw new Error("Single.onErrorResumeNext: returned an non-Single.")}catch(e){return void c(new Error([r,e]))}else e=i;u.unlink(),e.subscribeWith({onSubscribe(r){u.link(r)},onSuccess:n,onError:c})}})}var Lr=(r,e)=>{if(!s(e)&&!g(e))return r;const n=new Xr(Ar);return n.source=r,n.resumeIfError=e,n};function Or(r){const{onSuccess:e,onError:n,onSubscribe:s}=E(r),{source:c,item:o}=this;c.subscribeWith({onSubscribe:s,onSuccess:e,onError(r){let s;try{if(s=o(r),t(s))throw new Error(new Error("Single.onErrorReturn: returned a null value."))}catch(e){return void n([r,e])}e(s)}})}var zr=(r,e)=>{if(!s(e))return r;const n=new Xr(Or);return n.source=r,n.item=e,n};function Pr(r){const{onSuccess:e,onSubscribe:n}=E(r),{source:s,item:c}=this;s.subscribeWith({onSubscribe:n,onSuccess:e,onError(){e(c)}})}var Rr=(r,e)=>{if(t(e))return r;const n=new Xr(Pr);return n.source=r,n.item=e,n};let xr;var Br=()=>(t(xr)&&(xr=new Xr(e=>e.onSubscribe(r.UNCANCELLED))),xr);function Ir(e){const{onSubscribe:n,onSuccess:c,onError:o}=E(e),t=new r.LinkedCancellable;n(t);const{source:i,bipredicate:u}=this;let l=-1;const a=()=>{l+=1,t.unlink(),i.subscribeWith({onSubscribe(r){t.link(r)},onSuccess:c,onError(r){if(s(u)){u(l,r)?a():o(r)}else a()}})};a()}var Ur=(r,e)=>{const n=new Xr(Ir);return n.source=r,n.bipredicate=e,n};function Nr(e){const{onSubscribe:n,onSuccess:s,onError:c}=E(e),{source:o,scheduler:t}=this,i=new r.LinkedCancellable;n(i),i.link(t.schedule(()=>{i.unlink(),o.subscribeWith({onSubscribe(r){i.link(r)},onSuccess:s,onError:c})}))}var Tr=(r,e)=>{const n=new Xr(Nr);return n.source=r,n.scheduler=v(e),n};function jr(e){const{onSubscribe:n,onSuccess:s,onError:c}=E(e),o=new r.CompositeCancellable;n(o);const{source:t,other:i}=this;i.subscribeWith({onSubscribe(r){o.add(r)},onSuccess(){c(new Error("Single.takeUntil: Source cancelled by other Single.")),o.cancel()},onError(r){c(new Error(["Single.takeUntil: Source cancelled by other Single.",r])),o.cancel()}}),t.subscribeWith({onSubscribe(r){o.add(r)},onSuccess(r){s(r),o.cancel()},onError(r){c(r),o.cancel()}})}const Dr=(r,e)=>{if(!g(e))return r;const n=new Xr(jr);return n.source=r,n.other=e,n};function Mr(r){const{onSuccess:e,onSubscribe:n}=E(r);n(this.scheduler.delay(()=>e(0),this.amount))}var Fr=(r,e)=>{if(!c(r))return p(new Error('Single.timer: "amount" is not a number.'));const n=new Xr(Mr);return n.amount=r,n.scheduler=v(e),n};function qr(e){const{onSuccess:n,onError:s,onSubscribe:c}=E(e),{amount:o,scheduler:t}=this,i=new r.LinkedCancellable;c(i);const u=t.delay(()=>{s(new Error("Single.timeout: TimeoutException (no success signals within the specified timeout).")),i.cancel()},o);i.addEventListener("cancel",()=>u.cancel()),this.source.subscribeWith({onSubscribe(r){i.link(r)},onSuccess:n,onError:s})}var Gr=(r,e,n)=>{if(!c(e))return r;const s=new Xr(qr);return s.source=r,s.amount=e,s.scheduler=v(n),s};const Hr=r=>r;function Jr(e){const{onSuccess:n,onError:s,onSubscribe:c}=E(e),o=[],{sources:i,zipper:u}=this,l=i.length;if(0===l)w(e,new Error("Single.zipArray: source array is empty"));else{const e=new r.CompositeCancellable;c(e);let a=l;for(let r=0;r<l;r+=1){if(e.cancelled)return;const c=i[r];if(!g(c))return s(new Error("Single.zipArray: One of the sources is non-Single.")),void e.cancel();c.subscribeWith({onSubscribe(r){e.add(r)},onSuccess(c){if(o[r]=c,0===(a-=1)){let r;try{if(r=u(o),t(r))throw new Error("Single.zipArray: zipper function returned a null value.")}catch(r){return s(r),void e.cancel()}n(r),e.cancel()}},onError(r){s(r),e.cancel()}})}}}var Kr=(r,e)=>{if(!l(r))return p(new Error("Single.zipArray: sources is a non-Array."));let n=e;s(e)||(n=Hr);const c=new Xr(Jr);return c.sources=r,c.zipper=n,c},Qr=(r,e)=>{if(!a(r))return p(new Error("Single.zip: sources is a non-Iterable."));const n=[];for(const e of r){if(!g(e))return p(new Error("Single.zip: one of the sources is not a Single."));n.push(e)}return Kr(n,e)},Vr=(r,e,n)=>g(e)?Kr([r,e],n):r;class Xr{constructor(r){this.subscribeActual=r}static create(r){return R(r)}static amb(r){return y(r)}static ambArray(r){return C(r)}ambWith(r){return A(this,r)}cache(){return O(this)}compose(r){return x(this,r)}contains(r,e){return U(this,r,e)}static defer(r){return T(r)}delay(r,e,n){return D(this,r,e,n)}delaySubscription(r,e){return F(this,r,e)}delayUntil(r){return G(this,r)}doAfterSuccess(r){return J(this,r)}doAfterTerminate(r){return Q(this,r)}doFinally(r){return X(this,r)}doOnCancel(r){return Z(this,r)}doOnError(r){return _(this,r)}doOnEvent(r){return er(this,r)}doOnSubscribe(r){return or(this,r)}doOnSuccess(r){return sr(this,r)}doOnTerminate(r){return ir(this,r)}static error(r){return p(r)}flatMap(r){return lr(this,r)}static fromCallable(r){return Sr(r)}static fromPromise(r){return br(r)}static fromResolvable(r){return Er(r)}static just(r){return wr(r)}lift(r){return mr(this,r)}map(r){return gr(this,r)}static merge(r){return yr(r)}static never(){return Br()}observeOn(r){return Cr(this,r)}onErrorResumeNext(r){return Lr(this,r)}onErrorReturn(r){return zr(this,r)}onErrorReturnItem(r){return Rr(this,r)}retry(r){return Ur(this,r)}subscribeOn(r){return Tr(this,r)}subscribeWith(r){b(r)&&this.subscribeActual.call(this,r)}subscribe(e,n){const s=new r.LinkedCancellable;return this.subscribeWith({onSubscribe(r){s.link(r)},onSuccess:e,onError:n}),s}takeUntil(r){return Dr(this,r)}static timer(r,e){return Fr(r,e)}timeout(r,e){return Gr(this,r,e)}static zip(r,e){return Qr(r,e)}static zipArray(r,e){return Kr(r,e)}zipWith(r,e){return Vr(this,r,e)}toPromise(){return new Promise((r,e)=>{this.subscribe(r,e)})}then(r,e){return this.toPromise().then(r,e)}catch(r){return this.toPromise().catch(r)}}return Xr}(Cancellable,Scheduler);