var Single=function(r,e){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e;const n=(r,e)=>typeof r===e,c=r=>n(r,"function"),s=r=>n(r,"number"),o=r=>n(r,"object"),t=r=>null==r,i=r=>null!=r,u=(r,e)=>r instanceof e,l=r=>u(r,Array),a=r=>o(r)&&c(r.onSubscribe),b=r=>!t(r)&&(!!u(r,Promise)||(o(r)||c(r))&&c(r.then)),h=r=>r,S=r=>{throw r},f=r=>({onSubscribe:r.onSubscribe,onSuccess:c(r.onSuccess)?r.onSuccess:h,onError:c(r.onError)?r.onError:S}),E=(e,n)=>{const{onSubscribe:c,onSuccess:s}=f(e),o=new r.BooleanCancellable;c(o),o.cancelled||(s(n),o.cancel())},d=(e,n)=>{const{onSubscribe:c,onError:s}=f(e),o=new r.BooleanCancellable;c(o),o.cancelled||(s(n),o.cancel())};function w(r){let e;try{if(e=this.supplier(),t(e))throw new Error("Single.error: Error supplier returned a null value.")}catch(r){e=r}d(r,e)}var v=r=>{let e=r;u(r,Error)||c(r)||(e=new Error("Single.error received a non-Error value.")),c(r)||(e=(r=>()=>r)(e));const n=new Kr(w);return n.supplier=e,n},m=r=>r instanceof Kr;function p(e){const{onSuccess:n,onError:c,onSubscribe:s}=f(e),o=new r.CompositeCancellable;s(o);const{sources:t}=this;for(const r of t){if(o.cancelled)return;if(!m(r)){c(new Error("Single.amb: One of the sources is a non-Single.")),o.cancel();break}r.subscribeWith({onSubscribe(r){o.add(r)},onSuccess(r){n(r),o.cancel()},onError(r){c(r),o.cancel()}})}}var k=r=>{if(!(r=>o(r)&&c(r[Symbol.iterator]))(r))return v(new Error("Single.amb: sources is not Iterable."));const e=new Kr(p);return e.sources=r,e};function g(e){const{onSuccess:n,onError:c,onSubscribe:s}=f(e),{sources:o}=this,{length:t}=o;if(0===t)d(e,new Error("Single.ambArray: sources Array is empty."));else{const e=new r.CompositeCancellable;s(e);for(let r=0;r<t;r+=1){const s=o[r];if(e.cancelled)return;if(!m(s)){c(new Error("Single.ambArray: One of the sources is a non-Single.")),e.cancel();break}s.subscribeWith({onSubscribe(r){e.add(r)},onSuccess(r){n(r),e.cancel()},onError(r){c(r),e.cancel()}})}}}var y=r=>{if(!l(r))return v(new Error("Single.ambArray: sources is not an Array."));const e=new Kr(g);return e.sources=r,e},W=(r,e)=>m(e)?y([r,e]):r;function C(e){const{onSuccess:n,onError:c,onSubscribe:s}=f(e),{source:o,cached:t,observers:u,subscribed:l}=this;if(t){const e=new r.BooleanCancellable;s(e);const{value:o,error:t}=this;i(o)&&n(o),i(t)&&c(t),e.cancel()}else{const n=u.length;u[n]=e;const c=new r.BooleanCancellable;c.addEventListener("cancel",()=>{u.splice(n,1)}),s(c),l||(o.subscribeWith({onSubscribe(){},onSuccess:r=>{this.cached=!0,this.value=r;for(const e of u)e.onSuccess(r);c.cancel(),this.observers=void 0},onError:r=>{this.cached=!0,this.error=r;for(const e of u)e.onError(r);c.cancel(),this.observers=void 0}}),this.subscribed=!0)}}var A=r=>{const e=new Kr(C);return e.source=r,e.cached=!1,e.subscribed=!1,e.observers=[],e};class L extends r.Cancellable{constructor(e,n){super(),this.success=e,this.error=n,this.link=new r.BooleanCancellable}get cancelled(){return this.link.cancelled}cancel(){return this.link.cancel()}setCancellable(e){if(u(e,r.Cancellable)){if(!this.cancelled){if(e.cancelled)return this.cancel(),!0;{const{link:r}=this;return this.link=e,r.cancel(),!0}}e.cancel()}return!1}onSuccess(r){if(!this.cancelled)try{t(r)?this.error(new Error("onSuccess called with a null value.")):this.success(r)}finally{this.cancel()}}onError(r){let e=r;if(u(r,Error)||(e=new Error("onError called with a non-Error value.")),!this.cancelled)try{this.error(e)}finally{this.cancel()}}}function O(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),s=new L(e,n);c(s);try{this.subscriber(s)}catch(r){s.onError(r)}}var z=r=>{if(!c(r))return v(new Error("Single.create: There are no subscribers."));const e=new Kr(O);return e.subscriber=r,e},P=(r,e)=>{if(!c(e))return r;let n;try{if(n=e(r),!m(n))throw new Error("Single.compose: transformer returned a non-Single.")}catch(r){n=v(r)}return n};const R=(r,e)=>r===e;function x(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),{value:s,comparer:o}=this;this.source.subscribeWith({onSubscribe:c,onSuccess(r){let c;try{c=o(r,s)}catch(r){return void n(r)}e(c)},onError:n})}var B=(r,e,n)=>{if(t(e))return r;let s=n;c(s)||(s=R);const o=new Kr(x);return o.source=r,o.value=e,o.comparer=s,o};function U(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r);let s,o;try{if(s=this.supplier(),!m(s))throw new Error("Single.defer: supplier returned a non-Single.")}catch(r){o=r}i(o)?d(r,o):s.subscribeWith({onSubscribe:c,onSuccess:e,onError:n})}var I=r=>{const e=new Kr(U);return e.supplier=r,e};function N(e){const{onSuccess:n,onError:c,onSubscribe:s}=f(e),{amount:o,scheduler:t,doDelayError:i}=this,u=new r.LinkedCancellable;s(u),this.source.subscribeWith({onSubscribe(r){u.link(r)},onSuccess(r){u.link(t.delay(()=>{n(r)},o))},onError(r){u.link(t.delay(()=>{c(r)},i?o:0))}})}var T=(r,n,c,o)=>{if(!s(n))return r;let t=c;u(t,e.interface)||(t=e.current);const i=new Kr(N);return i.source=r,i.amount=n,i.scheduler=t,i.doDelayError=o,i};function j(e){const{onSuccess:n,onError:c,onSubscribe:s}=f(e),{amount:o,scheduler:t,source:i}=this,u=new r.LinkedCancellable;s(u),u.link(t.delay(()=>{u.unlink(),i.subscribeWith({onSubscribe(r){u.link(r)},onSuccess:n,onError:c})},o))}var D=(r,n,c)=>{if(!s(n))return r;let o=c;u(o,e.interface)||(o=e.current);const t=new Kr(j);return t.source=r,t.amount=n,t.scheduler=o,t};function M(e){const{onSuccess:n,onError:c,onSubscribe:s}=f(e),{source:o,other:t}=this,i=new r.LinkedCancellable;s(i),t.subscribeWith({onSubscribe(r){i.link(r)},onSuccess(){i.unlink(),o.subscribeWith({onSubscribe(r){i.link(r)},onSuccess:n,onError:c})},onError:c})}var F=(r,e)=>{if(!m(e))return r;const n=new Kr(M);return n.source=r,n.other=e,n};function q(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),{source:s,callable:o}=this;s.subscribeWith({onSubscribe:c,onSuccess(r){e(r),o(r)},onError:n})}var G=(r,e)=>{if(!c(e))return r;const n=new Kr(q);return n.source=r,n.callable=e,n};function H(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),{source:s,callable:o}=this;s.subscribeWith({onSubscribe:c,onSuccess(r){e(r),o()},onError(r){n(r),o()}})}var J=(r,e)=>{if(!c(e))return r;const n=new Kr(H);return n.source=r,n.callable=e,n};function K(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),{source:s,callable:o}=this;let t=!1;s.subscribeWith({onSubscribe(r){r.addEventListener("cancel",()=>{t||(o(),t=!0)}),c(r)},onSuccess(r){e(r),t||(o(),t=!0)},onError(r){n(r),t||(o(),t=!0)}})}var Q=(r,e)=>{if(!c(e))return r;const n=new Kr(K);return n.source=r,n.callable=e,n};function V(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),{source:s,callable:o}=this;s.subscribeWith({onSubscribe(r){r.addEventListener("cancel",o),c(r)},onSuccess:e,onError:n})}var X=(r,e)=>{if(!c(e))return r;const n=new Kr(V);return n.source=r,n.callable=e,n};function Y(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),{source:s,callable:o}=this;s.subscribeWith({onSubscribe:c,onSuccess:e,onError(r){o(r),n(r)}})}var Z=(r,e)=>{if(!c(e))return r;const n=new Kr(Y);return n.source=r,n.callable=e,n};function $(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),{source:s,callable:o}=this;s.subscribeWith({onSubscribe:c,onSuccess(r){o(r),e(r)},onError(r){o(void 0,r),n(r)}})}var _=(r,e)=>{if(!c(e))return r;const n=new Kr($);return n.source=r,n.callable=e,n};function rr(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),{source:s,callable:o}=this;s.subscribeWith({onSubscribe:c,onSuccess(r){o(r),e(r)},onError:n})}var er=(r,e)=>{if(!c(e))return r;const n=new Kr(rr);return n.source=r,n.callable=e,n};function nr(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),{source:s,callable:o}=this;s.subscribeWith({onSubscribe(r){o(r),c(r)},onSuccess:e,onError:n})}var cr=(r,e)=>{if(!c(e))return r;const n=new Kr(nr);return n.source=r,n.callable=e,n};function sr(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),{source:s,callable:o}=this;s.subscribeWith({onSubscribe:c,onSuccess(r){o(),e(r)},onError(r){o(),n(r)}})}var or=(r,e)=>{if(!c(e))return r;const n=new Kr(sr);return n.source=r,n.callable=e,n};function tr(e){const{onSubscribe:n,onError:c,onSuccess:s}=f(e),o=new r.LinkedCancellable;n(o);const{mapper:t,source:i}=this;i.subscribeWith({onSubscribe(r){o.link(r)},onSuccess(r){let e;o.unlink();try{if(e=t(r),!m(e))throw new Error("Single.flatMap: mapper returned a non-Single")}catch(r){return c(r),void o.cancel()}e.subscribeWith({onSubscribe(r){o.link(r)},onSuccess:s,onError:c})},onError:c})}var ir=(r,e)=>{if(!c(e))return r;const n=new Kr(tr);return n.source=r,n.mapper=e,n};function ur(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),s=new L(e,n);c(s),this.promise.then(r=>s.onSuccess(r),r=>s.onError(r))}var lr=r=>{if(!b(r))return v(new Error("Single.fromPromise: expects a Promise-like value."));const e=new Kr(ur);return e.promise=r,e};function ar(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),s=new L(e,n);let o;c(s);try{o=this.callable()}catch(r){return void s.onError(r)}b(o)?lr(o).subscribeWith({onSubscribe(r){s.setCancellable(r)},onSuccess(r){s.onSuccess(r)},onError(r){s.onError(r)}}):s.onSuccess(o)}var br=r=>{if(!c(r))return v(new Error("Single.fromCallable: callable received is not a function."));const e=new Kr(ar);return e.callable=r,e};function hr(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),s=new L(e,n);c(s),this.subscriber(r=>s.onSuccess(r),r=>s.onError(r))}var Sr=r=>{if(!c(r))return v(new Error("Single.fromResolvable: expects a function."));const e=new Kr(hr);return e.subscriber=r,e};function fr(r){E(r,this.value)}var Er=r=>{if(t(r))return v(new Error("Single.just: received a null value."));const e=new Kr(fr);return e.value=r,e};function dr(r){let e;try{if(e=this.operator(r),!a(e))throw new Error("Single.lift: operator returned a non-Observer.")}catch(e){return void d(r,e)}this.source.subscribeWith(e)}var wr=(r,e)=>{if(!c(e))return r;const n=new Kr(dr);return n.source=r,n.operator=e,n};function vr(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),{mapper:s}=this;this.source.subscribeWith({onSubscribe:c,onSuccess(r){let c;try{if(c=s(r),t(c))throw new Error("Single.map: mapper function returned a null value.")}catch(r){return void n(r)}e(c)},onError:n})}var mr=(r,e)=>{if(!c(e))return r;const n=new Kr(vr);return n.source=r,n.mapper=e,n};function pr(e){const{onSubscribe:n,onError:c,onSuccess:s}=f(e),o=new r.LinkedCancellable;n(o),this.source.subscribeWith({onSubscribe(r){o.link(r)},onSuccess(r){o.unlink();let e=r;m(r)||(e=v(new Error("Single.merge: source emitted a non-Single value."))),e.subscribeWith({onSubscribe(r){o.link(r)},onSuccess:s,onError:c})},onError:c})}var kr=r=>{if(!m(r))return v(new Error("Single.merge: source is not a Single."));const e=new Kr(pr);return e.source=r,e};function gr(e){const{onSubscribe:n,onSuccess:c,onError:s}=f(e),{source:o,scheduler:t}=this,i=new r.LinkedCancellable;n(i),o.subscribeWith({onSubscribe(r){i.link(r)},onSuccess(r){i.link(t.schedule(()=>{c(r)}))},onError(r){i.link(t.schedule(()=>{s(r)}))}})}var yr=(r,n)=>{let c=n;u(c,e.interface)||(c=e.current);const s=new Kr(gr);return s.source=r,s.scheduler=c,s};function Wr(e){const{onSuccess:n,onError:s,onSubscribe:o}=f(e),{source:t,resumeIfError:i}=this,u=new r.LinkedCancellable;o(u),t.subscribeWith({onSubscribe(r){u.link(r)},onSuccess:n,onError(r){let e;if(u.unlink(),c(i))try{if(e=i(r),!m(e))throw new Error("Single.onErrorResumeNext: returned an non-Single.")}catch(e){return s(new Error([r,e])),void u.cancel()}else e=i;e.subscribeWith({onSubscribe(r){u.link(r)},onSuccess:n,onError:s})}})}var Cr=(r,e)=>{if(!c(e)&&!m(e))return r;const n=new Kr(Wr);return n.source=r,n.resumeIfError=e,n};function Ar(r){const{onSuccess:e,onError:n,onSubscribe:c}=f(r),{source:s,item:o}=this;s.subscribeWith({onSubscribe:c,onSuccess:e,onError(r){let c;try{if(c=o(r),t(c))throw new Error(new Error("Single.onErrorReturn: returned a null value."))}catch(e){return void n([r,e])}e(c)}})}var Lr=(r,e)=>{if(!c(e))return r;const n=new Kr(Ar);return n.source=r,n.item=e,n};function Or(r){const{onSuccess:e,onSubscribe:n}=f(r),{source:c,item:s}=this;c.subscribeWith({onSubscribe:n,onSuccess:e,onError(){e(s)}})}var zr=(r,e)=>{if(t(e))return r;const n=new Kr(Or);return n.source=r,n.item=e,n};let Pr;var Rr=()=>(t(Pr)&&(Pr=new Kr(e=>e.onSubscribe(r.UNCANCELLED))),Pr);function xr(e){const{onSubscribe:n,onSuccess:s,onError:o}=f(e),t=new r.LinkedCancellable;n(t);const{source:i,bipredicate:u}=this;let l=0;const a=()=>{l+=1,t.unlink(),i.subscribeWith({onSubscribe(r){t.link(r)},onSuccess:s,onError(r){if(c(u)){u(l,r)?a():(o(r),t.cancel())}else a()}})};a()}var Br=(r,e)=>{const n=new Kr(xr);return n.source=r,n.bipredicate=e,n};function Ur(e){const{onSubscribe:n,onSuccess:c,onError:s}=f(e),{source:o,scheduler:t}=this,i=new r.LinkedCancellable;n(i),i.link(t.schedule(()=>{i.unlink(),o.subscribeWith({onSubscribe(r){i.link(r)},onSuccess:c,onError:s})}))}var Ir=(r,n)=>{let c=n;u(c,e.interface)||(c=e.current);const s=new Kr(Ur);return s.source=r,s.scheduler=c,s};function Nr(e){const{onSubscribe:n,onSuccess:c,onError:s}=f(e),o=new r.CompositeCancellable;n(o);const{source:t,other:i}=this;i.subscribeWith({onSubscribe(r){o.add(r)},onSuccess(){s(new Error("Single.takeUntil: Source cancelled by other Single.")),o.cancel()},onError(r){s(new Error(["Single.takeUntil: Source cancelled by other Single.",r])),o.cancel()}}),t.subscribeWith({onSubscribe(r){o.add(r)},onSuccess(r){c(r),o.cancel()},onError(r){s(r),o.cancel()}})}const Tr=(r,e)=>{if(!m(e))return r;const n=new Kr(Nr);return n.source=r,n.other=e,n};function jr(r){const{onSuccess:e,onSubscribe:n}=f(r);n(this.scheduler.delay(()=>e(0),this.amount))}var Dr=(r,n)=>{if(!s(r))return v(new Error('Single.timer: "amount" is not a number.'));let c=n;u(c,e.interface)||(c=e.current);const o=new Kr(jr);return o.amount=r,o.scheduler=c,o};function Mr(e){const{onSuccess:n,onError:c,onSubscribe:s}=f(e),{amount:o,scheduler:t}=this,i=new r.LinkedCancellable;s(i);const u=t.delay(()=>{c(new Error("Single.timeout: TimeoutException (no success signals within the specified timeout).")),i.cancel()},o);i.addEventListener("cancel",()=>u.cancel()),this.source.subscribeWith({onSubscribe(r){i.link(r)},onSuccess:n,onError:c})}var Fr=(r,n,c)=>{if(!s(n))return r;let o=c;u(o,e.interface)||(o=e.current);const t=new Kr(Mr);return t.source=r,t.amount=n,t.scheduler=o,t};const qr=r=>r;function Gr(e){const{onSuccess:n,onError:c,onSubscribe:s}=f(e),o=[],i=new r.CompositeCancellable;s(i);const{sources:u,zipper:l}=this,a=u.length;if(0===a)return c(new Error("Single.zipArray: source array is empty")),void i.cancel();let b=a;for(let r=0;r<a;r+=1){if(i.cancelled)return;const e=u[r];if(!m(e))return c(new Error("Single.zipArray: One of the sources is non-Single.")),void i.cancel();e.subscribeWith({onSubscribe(r){i.add(r)},onSuccess(e){if(o[r]=e,0===(b-=1)){let r;try{if(r=l(o),t(r))throw new Error("Single.zipArray: zipper function returned a null value.")}catch(r){return c(r),void i.cancel()}n(r),i.cancel()}},onError(r){c(r),i.cancel()}})}}var Hr=(r,e)=>{if(!l(r))return v(new Error("Single.zipArray: sources is a non-Array."));let n=e;c(e)||(n=qr);const s=new Kr(Gr);return s.sources=r,s.zipper=n,s},Jr=(r,e,n)=>m(e)?Hr([r,e],n):r;class Kr{constructor(r){this.subscribeActual=r}static create(r){return z(r)}static amb(r){return k(r)}static ambArray(r){return y(r)}ambWith(r){return W(this,r)}cache(){return A(this)}compose(r){return P(this,r)}contains(r,e){return B(this,r,e)}static defer(r){return I(r)}delay(r,e,n){return T(this,r,e,n)}delaySubscription(r,e){return D(this,r,e)}delayUntil(r){return F(this,r)}doAfterSuccess(r){return G(this,r)}doAfterTerminate(r){return J(this,r)}doFinally(r){return Q(this,r)}doOnCancel(r){return X(this,r)}doOnError(r){return Z(this,r)}doOnEvent(r){return _(this,r)}doOnSubscribe(r){return cr(this,r)}doOnSuccess(r){return er(this,r)}doOnTerminate(r){return or(this,r)}static error(r){return v(r)}flatMap(r){return ir(this,r)}static fromCallable(r){return br(r)}static fromPromise(r){return lr(r)}static fromResolvable(r){return Sr(r)}static just(r){return Er(r)}lift(r){return wr(this,r)}map(r){return mr(this,r)}static merge(r){return kr(r)}static never(){return Rr()}observeOn(r){return yr(this,r)}onErrorResumeNext(r){return Cr(this,r)}onErrorReturn(r){return Lr(this,r)}onErrorReturnItem(r){return zr(this,r)}retry(r){return Br(this,r)}subscribeOn(r){return Ir(this,r)}subscribeWith(r){a(r)&&this.subscribeActual.call(this,r)}subscribe(e,n){const c=new r.LinkedCancellable;return this.subscribeWith({onSubscribe(r){c.link(r)},onSuccess:e,onError:n}),c}takeUntil(r){return Tr(this,r)}static timer(r,e){return Dr(r,e)}timeout(r,e){return Fr(this,r,e)}static zipArray(r,e){return Hr(r,e)}zipWith(r,e){return Jr(this,r,e)}toPromise(){return new Promise((r,e)=>{this.subscribe(r,e)})}then(r,e){return this.toPromise().then(r,e)}catch(r){return this.toPromise().catch(r)}}return Kr}(Cancellable,Scheduler);