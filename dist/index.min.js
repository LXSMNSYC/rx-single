var Single=function(r){"use strict";r=r&&r.hasOwnProperty("default")?r.default:r;const e=r=>"object"==typeof r&&"function"==typeof r[Symbol.iterator],n=r=>"object"==typeof r&&"function"==typeof r.onSubscribe,t=r=>r instanceof Promise||!!r&&("object"==typeof r||"function"==typeof r)&&"function"==typeof r.then;function o(r){const{onSuccess:e,onError:n,controller:t}=this;if(!t.signal.aborted)try{void 0===r?n("onSuccess called with a null value."):e(r)}finally{t.abort()}}function s(r){const{onError:e,controller:n}=this;let t=r;if(r instanceof Error||(t=new Error("onError called with a non-Error value.")),!n.signal.aborted)try{e(t)}finally{n.abort()}}const c=r=>r,i=r=>{throw r},u=r=>({onSubscribe:r.onSubscribe,onSuccess:"function"==typeof r.onSuccess?r.onSuccess:c,onError:"function"==typeof r.onError?r.onError:i}),b=(e,n)=>{const{onSubscribe:t,onSuccess:o}=u(e),s=new r;t(s),s.signal.aborted||(o(n),s.abort())},a=(e,n)=>{const{onSubscribe:t,onError:o}=u(e),s=new r;t(s),s.signal.aborted||(o(n),s.abort())};var l=r=>{let e=r;r instanceof Error||(e=new Error("Single.error received a non-Error value.")),"function"!=typeof r&&(e=(r=>()=>r)(e));const n=new er;return n.supplier=e,n.subscribeActual=function(r){let e;try{if(null==(e=this.supplier()))throw new Error("Single.error: Error supplier returned a null value.")}catch(r){e=r}a(r,e)}.bind(n),n};var f=n=>{if(!e(n))return l(new Error("Single.amb: sources is not Iterable."));const t=new er;return t.sources=n,t.subscribeActual=function(e){const{onSuccess:n,onError:t,onSubscribe:o}=u(e),s=new r,{signal:c}=s;if(o(s),c.aborted)return;const{sources:i}=this;for(const r of i){if(c.aborted)return;if(!(r instanceof er)){t(new Error("Single.amb: One of the sources is a non-Single.")),s.abort();break}r.subscribeWith({onSubscribe(r){c.addEventListener("abort",()=>r.abort())},onSuccess(r){n(r),s.abort()},onError(r){t(r),s.abort()}})}}.bind(t),t};var d=(e,n)=>{if(!(n instanceof er))return e;const t=new er;return t.source=e,t.other=n,t.subscribeActual=function(e){const{onSuccess:n,onError:t,onSubscribe:o}=u(e),s=new r,{signal:c}=s;if(o(s),c.aborted)return;const i=r=>{c.aborted||(n(r),s.abort())},b=r=>{c.aborted||(t(r),s.abort())},{source:a,other:l}=this;a.subscribeWith({onSubscribe(r){c.addEventListener("abort",()=>r.abort())},onSuccess:i,onError:b}),l.subscribeWith({onSubscribe(r){c.aborted?r.abort():c.addEventListener("abort",()=>r.abort())},onSuccess:i,onError:b})}.bind(t),t};var h=e=>{const n=new er;return n.source=e,n.cached=!1,n.subscribed=!1,n.observers=[],n.subscribeActual=function(e){const{onSuccess:n,onError:t,onSubscribe:o}=u(e),{source:s,cached:c,observers:i,subscribed:b}=this;if(c){const e=new r;o(e);const{value:s,error:c}=this;null!=s&&n(s),null!=c&&t(c),e.abort()}else{const n=i.length;i[n]=e;const t=new r;t.signal.addEventListener("abort",()=>{i.splice(n,1)}),o(t),b||(s.subscribeWith({onSubscribe(){},onSuccess:r=>{this.cached=!0,this.value=r;for(const e of i)e.onSuccess(r);this.observers=void 0},onError:r=>{this.cached=!0,this.error=r;for(const e of i)e.onError(r);this.observers=void 0}}),this.subscribed=!0)}}.bind(n),n};var S=e=>{if("function"!=typeof e)return l(new Error("Single.create: There are no subscribers."));const n=new er;return n.subscriber=e,n.subscribeActual=function(e){const{onSuccess:n,onError:t,onSubscribe:c}=u(e),i=new r;i.onSuccess=o.bind(this),i.onError=s.bind(this),this.controller=i,this.onSuccess=n,this.onError=t,c(i);try{this.subscriber(i)}catch(r){i.onError(r)}}.bind(n),n},E=(r,e)=>{if("function"!=typeof e)return r;let n;try{if(!((n=e(r))instanceof er))throw new Error("Single.compose: transformer returned a non-Single.")}catch(r){n=l(r)}return n};const v=(r,e)=>r===e;var w=(r,e,n)=>{if(null==e)return r;let t=n;"function"!=typeof t&&(t=v);const o=new er;return o.source=r,o.value=e,o.comparer=t,o.subscribeActual=function(r){const{onSuccess:e,onError:n,onSubscribe:t}=u(r),{value:o,comparer:s}=this;this.source.subscribeWith({onSubscribe:t,onSuccess(r){let t;try{t=s(r,o)}catch(r){return void n(r)}e(t)},onError:n})}.bind(o),o};var p=r=>{const e=new er;return e.supplier=r,e.subscribeActual=function(r){const{onSuccess:e,onError:n,onSubscribe:t}=u(r);let o,s;try{if(!((o=this.supplier())instanceof er))throw new Error("Single.defer: supplier returned a non-Single.")}catch(r){s=r}null!=s?a(r,s):o.subscribeWith({onSubscribe:t,onSuccess:e,onError:n})}.bind(e),e};var m=(e,n,t)=>{if("number"!=typeof n)return e;const o=new er;return o.source=e,o.amount=n,o.doDelayError=t,o.subscribeActual=function(e){const{onSuccess:n,onError:t,onSubscribe:o}=u(e),{amount:s,doDelayError:c}=this;let i;const b=new r,{signal:a}=b;o(b),a.aborted||(a.addEventListener("abort",()=>{void 0!==i&&clearTimeout(i)}),this.source.subscribeWith({onSubscribe(r){a.addEventListener("abort",()=>{r.abort()})},onSuccess(r){i=setTimeout(()=>{n(r),b.abort()},s)},onError(r){i=setTimeout(()=>{t(r),b.abort()},c?s:0)}}))}.bind(o),o};var g=(e,n)=>{if("number"!=typeof n)return e;const t=new er;return t.source=e,t.amount=n,t.subscribeActual=function(e){const{onSuccess:n,onError:t,onSubscribe:o}=u(e),{amount:s}=this;let c;const i=new r,{signal:b}=i;b.addEventListener("abort",()=>{void 0!==c&&clearTimeout(c)}),o(i),b.aborted||(c=setTimeout(()=>{this.source.subscribeWith({onSubscribe(r){b.addEventListener("abort",()=>r.abort())},onSuccess(r){n(r),i.abort()},onError(r){t(r),i.abort()}})},s))}.bind(t),t};var y=(e,n)=>{if(!(n instanceof er))return e;const t=new er;return t.source=e,t.other=n,t.subscribeActual=function(e){const{onSuccess:n,onError:t,onSubscribe:o}=u(e),{source:s,other:c}=this,i=new r,{signal:b}=i;o(i),b.aborted||c.subscribeWith({onSubscribe(r){b.addEventListener("abort",()=>r.abort())},onSuccess(){b.aborted||s.subscribeWith({onSubscribe(r){b.addEventListener("abort",()=>r.abort())},onSuccess(r){n(r),i.abort()},onError(r){t(r),i.abort()}})},onError(r){t(r),i.abort()}})}.bind(t),t};var A=(r,e)=>{if("function"!=typeof e)return r;const n=new er;return n.source=r,n.callable=e,n.subscribeActual=function(r){const{onSuccess:e,onError:n,onSubscribe:t}=u(r),{source:o,callable:s}=this;o.subscribeWith({onSubscribe:t,onSuccess(r){e(r),s(r)},onError:n})}.bind(n),n};var W=(r,e)=>{if("function"!=typeof e)return r;const n=new er;return n.source=r,n.callable=e,n.subscribeActual=function(r){const{onSuccess:e,onError:n,onSubscribe:t}=u(r),{source:o,callable:s}=this;o.subscribeWith({onSubscribe:t,onSuccess(r){e(r),s()},onError(r){n(r),s()}})}.bind(n),n};var L=(r,e)=>{if("function"!=typeof e)return r;const n=new er;return n.source=r,n.callable=e,n.subscribeActual=function(r){const{onSuccess:e,onError:n,onSubscribe:t}=u(r),{source:o,callable:s}=this;let c=!1;o.subscribeWith({onSubscribe(r){r.signal.addEventListener("abort",()=>{c||(s(),c=!0)}),t(r)},onSuccess(r){e(r),c||(s(),c=!0)},onError(r){n(r),c||(s(),c=!0)}})}.bind(n),n};var z=(r,e)=>{if("function"!=typeof e)return r;const n=new er;return n.source=r,n.callable=e,n.subscribeActual=function(r){const{onSuccess:e,onError:n,onSubscribe:t}=u(r),{source:o,callable:s}=this;o.subscribeWith({onSubscribe(r){r.signal.addEventListener("abort",s),t(r)},onSuccess:e,onError:n})}.bind(n),n};var T=(r,e)=>{if("function"!=typeof e)return r;const n=new er;return n.source=r,n.callable=e,n.subscribeActual=function(r){const{onSuccess:e,onError:n,onSubscribe:t}=u(r),{source:o,callable:s}=this;o.subscribeWith({onSubscribe:t,onSuccess:e,onError(r){s(r),n(r)}})}.bind(n),n};var O=(r,e)=>{if("function"!=typeof e)return r;const n=new er;return n.source=r,n.callable=e,n.subscribeActual=function(r){const{onSuccess:e,onError:n,onSubscribe:t}=u(r),{source:o,callable:s}=this;o.subscribeWith({onSubscribe:t,onSuccess(r){s(r),e(r)},onError(r){s(void 0,r),n(r)}})}.bind(n),n};var P=(r,e)=>{if("function"!=typeof e)return r;const n=new er;return n.source=r,n.callable=e,n.subscribeActual=function(r){const{onSuccess:e,onError:n,onSubscribe:t}=u(r),{source:o,callable:s}=this;o.subscribeWith({onSubscribe:t,onSuccess(r){s(r),e(r)},onError:n})}.bind(n),n};var R=(r,e)=>{if("function"!=typeof e)return r;const n=new er;return n.source=r,n.callable=e,n.subscribeActual=function(r){const{onSuccess:e,onError:n,onSubscribe:t}=u(r),{source:o,callable:s}=this;o.subscribeWith({onSubscribe(r){s(r),t(r)},onSuccess:e,onError:n})}.bind(n),n};var k=(r,e)=>{if("function"!=typeof e)return r;const n=new er;return n.source=r,n.callable=e,n.subscribeActual=function(r){const{onSuccess:e,onError:n,onSubscribe:t}=u(r),{source:o,callable:s}=this;o.subscribeWith({onSubscribe:t,onSuccess(r){s(),e(r)},onError(r){s(),n(r)}})}.bind(n),n};var j=(e,n)=>{if("function"!=typeof n)return e;const t=new er;return t.source=e,t.mapper=n,t.subscribeActual=function(e){const{onSubscribe:n,onError:t,onSuccess:o}=u(e),s=new r,{signal:c}=s;if(n(s),c.aborted)return;const{mapper:i,source:b}=this;b.subscribeWith({onSubscribe(r){c.addEventListener("abort",()=>r.abort())},onSuccess(r){let e;try{if(!((e=i(r))instanceof er))throw new Error("Single.flatMap: mapper returned a non-Single")}catch(r){return void t(r)}e.subscribeWith({onSubscribe(r){c.addEventListener("abort",()=>r.abort())},onSuccess(r){o(r),s.abort()},onError(r){t(r),s.abort()}})},onError(r){t(r),s.abort()}})}.bind(t),t};var x=e=>{if("function"!=typeof e)return l(new Error("Single.fromCallable: callable received is not a function."));const n=new er;return n.callable=e,n.subscribeActual=function(e){const{onSuccess:n,onError:c,onSubscribe:i}=u(e),b=new r;if(i(b),b.signal.aborted)return;this.controller=b,this.onSuccess=n,this.onError=c;const a=o.bind(this),l=s.bind(this);let f;try{f=this.callable()}catch(r){return void l(r)}t(f)?I(f).subscribe(n,c):a(f)}.bind(n),n};var I=e=>{if(!t(e))return l(new Error("Single.fromPromise: expects a Promise-like value."));const n=new er;return n.promise=e,n.subscribeActual=function(e){const{onSuccess:n,onError:t,onSubscribe:c}=u(e),i=new r;c(i),i.signal.aborted||(this.controller=i,this.onSuccess=n,this.onError=t,this.promise.then(o.bind(this),s.bind(this)))}.bind(n),n};var U=e=>{if("function"!=typeof e)return l(new Error("Single.fromResolvable: expects a function."));const n=new er;return n.subscriber=e,n.subscribeActual=function(e){const{onSuccess:n,onError:t,onSubscribe:c}=u(e),i=new r;if(c(i),i.signal.aborted)return;this.controller=i,this.onSuccess=n,this.onError=t;const b=o.bind(this),a=s.bind(this);this.subscriber(b,a)}.bind(n),n};var C=r=>{if(null==r)return l(new Error("Single.just: received a null value."));const e=new er;return e.value=r,e.subscribeActual=function(r){b(r,this.value)}.bind(e),e};var D=(r,e)=>{if("function"!=typeof e)return r;const t=new er;return t.source=r,t.operator=e,t.subscribeActual=function(r){let e;try{if(e=this.operator(r),!n(e))throw new Error("Single.lift: operator returned a non-Observer.")}catch(e){return void a(r,e)}this.source.subscribeWith(e)}.bind(t),t};const M=r=>r;var N=(r,e)=>{let n=e;"function"!=typeof e&&(n=M);const t=new er;return t.source=r,t.mapper=n,t.subscribeActual=function(r){const{onSuccess:e,onError:n,onSubscribe:t}=u(r),{mapper:o}=this;this.source.subscribeWith({onSubscribe:t,onSuccess(r){let t;try{if(null==(t=o(r)))throw new Error("Single.map: mapper function returned a null value.")}catch(r){return void n(r)}e(t)},onError:n})}.bind(t),t};var F=e=>{if(!(e instanceof er))return l(new Error("Single.merge: source is not a Single."));const n=new er;return n.source=e,n.subscribeActual=function(e){const{onSubscribe:n,onError:t,onSuccess:o}=u(e),s=new r,{signal:c}=s;n(s),c.aborted||this.source.subscribeWith({onSubscribe(r){c.addEventListener("abort",()=>r.abort())},onSuccess(r){let e=r;r instanceof er||(e=l(new Error("Single.merge: source emitted a non-Single value."))),e.subscribeWith({onSubscribe(r){c.addEventListener("abort",()=>r.abort())},onSuccess(r){o(r),s.abort()},onError(r){t(r),s.abort()}})},onError(r){t(r),s.abort()}})}.bind(n),n};var q=(e,n)=>{if(!("function"==typeof n||n instanceof er))return e;const t=new er;return t.source=e,t.resumeIfError=n,t.subscribeActual=function(e){const{onSuccess:n,onError:t,onSubscribe:o}=u(e),{source:s,resumeIfError:c}=this,i=new r,{signal:b}=i;o(i),b.aborted||s.subscribeWith({onSubscribe(r){b.addEventListener("abort",()=>r.abort())},onSuccess(r){n(r),i.abort()},onError(r){let e;if("function"==typeof c)try{if(!((e=c(r))instanceof er))throw new Error("Single.onErrorResumeNext: returned an non-Single.")}catch(e){return void t(new Error([r,e]))}else e=c;e.subscribeWith({onSubscribe(r){b.addEventListener("abort",()=>r.abort())},onSuccess(r){n(r),i.abort()},onError(r){t(r),i.abort()}})}})}.bind(t),t};var B=(r,e)=>{if("function"!=typeof e)return r;const n=new er;return n.source=r,n.item=e,n.subscribeActual=function(r){const{onSuccess:e,onError:n,onSubscribe:t}=u(r),{source:o,item:s}=this;o.subscribeWith({onSubscribe:t,onSuccess:e,onError(r){let t;try{if(null==(t=s(r)))throw new Error(new Error("Single.onErrorReturn: returned a null value."))}catch(e){return void n([r,e])}e(t)}})}.bind(n),n};var G=(r,e)=>{if(null==e)return r;const n=new er;return n.source=r,n.item=e,n.subscribeActual=function(r){const{onSuccess:e,onSubscribe:n}=u(r),{source:t,item:o}=this;t.subscribeWith({onSubscribe:n,onSuccess:e,onError(){e(o)}})}.bind(n),n};const H={signal:{aborted:!1,addEventListener:()=>{},removeEventListener:()=>{},onabort:()=>{}},abort:()=>{}};let J;var K=()=>(void 0===J&&((J=new er).subscribeActual=function(r){r.onSubscribe(H)}.bind(J)),J);var Q=(e,n)=>{const t=new er;return t.source=e,t.bipredicate=n,t.subscribeActual=function(e){const{onSubscribe:n,onSuccess:t,onError:o}=u(e),s=new r,{signal:c}=s;if(n(s),c.aborted)return;const{source:i,bipredicate:b}=this;let a=0;const l=()=>{c.aborted||(a+=1,i.subscribeWith({onSubscribe(r){c.addEventListener("abort",()=>r.abort())},onSuccess(r){t(r),s.abort()},onError(r){"function"==typeof b?b(a,r)?l():(o(r),s.abort()):l()}}))};l()}.bind(t),t};const V=(e,n)=>{if(!(n instanceof er))return e;const t=new er;return t.source=e,t.other=n,t.subscribeActual=function(e){const{onSubscribe:n,onSuccess:t,onError:o}=u(e),s=new r,{signal:c}=s;if(n(s),c.aborted)return;const{source:i,other:b}=this;b.subscribeWith({onSubscribe(r){c.addEventListener("abort",()=>r.abort())},onSuccess(){o(new Error("Single.takeUntil: Source cancelled by other Single.")),s.abort()},onError(r){o(new Error(["Single.takeUntil: Source cancelled by other Single.",r])),s.abort()}}),i.subscribeWith({onSubscribe(r){c.aborted?r.abort():c.addEventListener("abort",()=>r.abort())},onSuccess(r){t(r),s.abort()},onError(r){o(r),s.abort()}})}.bind(t),t};var X=e=>{if("number"!=typeof e)return l(new Error('Single.timer: "amount" is not a number.'));const n=new er;return n.amount=e,n.subscribeActual=function(e){const{onSuccess:n,onSubscribe:t}=u(e),o=new r,{signal:s}=o;if(t(o),s.aborted)return;const c=setTimeout(n,this.amount,0);s.addEventListener("abort",()=>{clearTimeout(c)})}.bind(n),n};var Y=(e,n)=>{if("number"!=typeof n)return e;const t=new er;return t.source=e,t.amount=n,t.subscribeActual=function(e){const{onSuccess:n,onError:t,onSubscribe:o}=u(e),{amount:s}=this,c=new r,{signal:i}=c;if(o(c),i.aborted)return;const b=setTimeout(()=>{t(new Error("Single.timeout: TimeoutException (no success signals within the specified timeout).")),c.abort()},s);i.addEventListener("abort",()=>{clearTimeout(b)}),this.source.subscribeWith({onSubscribe(r){i.addEventListener("abort",()=>r.abort())},onSuccess(r){n(r),c.abort()},onError(r){t(r),c.abort()}})}.bind(t),t};const Z=r=>r;var $=(n,t)=>{if(!e(n))return l(new Error("Single.zip: sources is not Iterable."));let o=t;"function"!=typeof t&&(o=Z);const s=new er;return s.sources=n,s.zipper=o,s.subscribeActual=function(e){const{onSuccess:n,onError:t,onSubscribe:o}=u(e),s=[],c=new r,{signal:i}=c;if(o(c),i.aborted)return;const{sources:b,zipper:a}=this,l=b.length;if(0===l)return t(new Error("Single.zip: empty iterable")),void c.abort();let f=l;for(let r=0;r<l;r+=1){if(i.aborted)return;const e=b[r];if(e instanceof er)e.subscribeWith({onSubscribe(r){i.addEventListener("abort",()=>r.abort())},onSuccess(e){if(!i.aborted&&(s[r]=e,0==(f-=1))){let r;try{if(null==(r=a(s)))throw new Error("Single.zip: zipper function returned a null value.")}catch(r){return t(r),void c.abort()}n(r),c.abort()}},onError(r){t(r),c.abort()}});else{if(null==e){t(new Error("Single.zip: One of the sources is undefined.")),c.abort();break}s[r]=e,f-=1}}}.bind(s),s};const _=(r,e)=>[r,e];var rr=(e,n,t)=>{if(!(n instanceof er))return e;let o=t;"function"!=typeof t&&(o=_);const s=new er;return s.source=e,s.other=n,s.zipper=o,s.subscribeActual=function(e){const{onSuccess:n,onError:t,onSubscribe:o}=u(e);let s,c;const i=new r,{signal:b}=i;if(o(i),b.aborted)return;const{source:a,other:l,zipper:f}=this;a.subscribeWith({onSubscribe(r){b.addEventListener("abort",()=>r.abort())},onSuccess(r){if(!b.aborted&&(s=r,null!=c)){let r;try{if(null==(r=f(s,c)))throw new Error("Single.zipWith: zipper function returned a null value.")}catch(r){return t(r),void i.abort()}n(r),i.abort()}},onError(r){t(r),i.abort()}}),l.subscribeWith({onSubscribe(r){b.aborted?r.abort():b.addEventListener("abort",()=>r.abort())},onSuccess(r){if(!b.aborted&&(c=r,null!=s)){let r;try{if(null==(r=f(s,c)))throw new Error("Single.zipWith: zipper function returned a null value.")}catch(r){return t(r),void i.abort()}n(r),i.abort()}},onError(r){t(r),i.abort()}})}.bind(s),s};class er{static create(r){return S(r)}static amb(r){return f(r)}ambWith(r){return d(this,r)}cache(){return h(this)}compose(r){return E(this,r)}contains(r,e){return w(this,r,e)}static defer(r){return p(r)}delay(r,e){return m(this,r,e)}delaySubscription(r){return g(this,r)}delayUntil(r){return y(this,r)}doAfterSuccess(r){return A(this,r)}doAfterTerminate(r){return W(this,r)}doFinally(r){return L(this,r)}doOnAbort(r){return z(this,r)}doOnError(r){return T(this,r)}doOnEvent(r){return O(this,r)}doOnSubscribe(r){return R(this,r)}doOnSuccess(r){return P(this,r)}doOnTerminate(r){return k(this,r)}static error(r){return l(r)}flatMap(r){return j(this,r)}static fromCallable(r){return x(r)}static fromPromise(r){return I(r)}static fromResolvable(r){return U(r)}static just(r){return C(r)}lift(r){return D(this,r)}map(r){return N(this,r)}static merge(r){return F(r)}static never(){return K()}onErrorResumeNext(r){return q(this,r)}onErrorReturn(r){return B(this,r)}onErrorReturnItem(r){return G(this,r)}retry(r){return Q(this,r)}subscribeWith(r){n(r)&&this.subscribeActual(r)}subscribe(e,n){const t=new r;let o=!1;return this.subscribeActual({onSubscribe(r){r.signal.addEventListener("abort",()=>{o||(o=!0,t.signal.aborted||t.abort())}),t.signal.addEventListener("abort",()=>{o||(o=!0,r.signal.aborted||r.abort())})},onSuccess:e,onError:n}),t}takeUntil(r){return V(this,r)}static timer(r){return X(r)}timeout(r){return Y(this,r)}static zip(r,e){return $(r,e)}zipWith(r,e){return rr(this,r,e)}toPromise(){return new Promise((r,e)=>{this.subscribe(r,e)})}then(r,e){return this.toPromise().then(r,e)}catch(r){return this.toPromise().catch(r)}}return er}(AbortController);